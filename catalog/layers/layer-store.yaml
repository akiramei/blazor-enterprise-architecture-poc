id: layer-store
version: 1.0.0
name: Store Pattern (State Management + I/O)
category: layer-element
intent: UI層の状態管理とI/Oを担当するStoreパターン
description: |
  Blazor UI層で使用するStoreパターン。
  フォームの状態管理、Command/Queryの送信、ローディング状態の管理を行います。
  WPF/WinFormsのViewModelに相当します。

layer: UI
responsibility:
  - フォーム状態の管理
  - Command/Queryの送信（MediatR経由）
  - ローディング状態の管理
  - エラー状態の管理
  - 変更通知（OnChangeAsync イベント）

comparison:
  wpf_winforms: "ViewModel"
  redux: "Store + Actions"
  mvc: "Controller (部分的)"

implementation:
  state:
    file_path: "src/Application/Infrastructure/{BoundedContext}/UI/Store/{Entity}{Operation}State.cs"
    template: |
      using System.Collections.Immutable;

      namespace {BoundedContext}.Shared.UI.Store;

      /// <summary>
      /// {Entity}{Operation}状態
      ///
      /// 【パターン: State（不変オブジェクト）】
      ///
      /// 責務:
      /// - UIの状態を保持する不変オブジェクト
      /// - record型でイミュータブルに実装
      /// - ImmutableListを使用してコレクションも不変に保つ
      /// </summary>
      public sealed record {Entity}{Operation}State
      {
          public ImmutableList<{Entity}Dto> {Entity}s { get; init; } = ImmutableList<{Entity}Dto>.Empty;
          public bool IsLoading { get; init; }
          public string? ErrorMessage { get; init; }

          public static {Entity}{Operation}State Empty => new();
      }

  store:
    file_path: "src/Application/Infrastructure/{BoundedContext}/UI/Store/{Entity}{Operation}Store.cs"
    template: |
      using System.Collections.Concurrent;
      using System.Collections.Immutable;
      using MediatR;
      using Microsoft.Extensions.DependencyInjection;
      using Microsoft.Extensions.Logging;

      namespace {BoundedContext}.Shared.UI.Store;

      /// <summary>
      /// {Entity}{Operation}の状態管理とI/O実行（並行制御強化版）
      ///
      /// 【パターン: Store（状態管理+I/O）】
      ///
      /// 責務:
      /// - 状態の保持と更新
      /// - MediatRを使用したCommand/Queryの送信
      /// - 変更通知（OnChangeAsync イベント）
      /// - 並行制御（SemaphoreSlim + single-flight + versioning）
      ///
      /// AI実装時の注意:
      /// - UI手順（確認ダイアログ、画面遷移、トースト）はPageActionsに実装
      /// - Storeは純粋にI/Oと状態管理のみ
      /// - IServiceScopeFactoryを使ってMediatRを取得（スコープ管理）
      /// </summary>
      public sealed class {Entity}{Operation}Store : IDisposable
      {
          private readonly IServiceScopeFactory _scopeFactory;
          private readonly ILogger<{Entity}{Operation}Store> _logger;

          // 並行制御用
          private readonly SemaphoreSlim _gate = new(1, 1);
          private readonly ConcurrentDictionary<string, Task> _inflightRequests = new();
          private CancellationTokenSource? _cts;

          // バージョン管理（連打対策）
          private long _version;

          // 状態（不変）
          private {Entity}{Operation}State _state = {Entity}{Operation}State.Empty;

          public event Func<Task>? OnChangeAsync;

          public {Entity}{Operation}Store(
              IServiceScopeFactory scopeFactory,
              ILogger<{Entity}{Operation}Store> logger)
          {
              _scopeFactory = scopeFactory;
              _logger = logger;
          }

          public {Entity}{Operation}State GetState() => _state;

          /// <summary>
          /// 同一キーの読み込みは合流し、結果を共有（single-flight）
          /// </summary>
          public Task LoadAsync(CancellationToken ct = default)
          {
              const string key = "{entity}s-load";  // 固有キー

              // single-flight: 同時リクエストは1つに合流
              return _inflightRequests.GetOrAdd(key, _ => LoadInternalAsync(ct))
                  .ContinueWith(t =>
                  {
                      _inflightRequests.TryRemove(key, out _);  // クリーンアップ
                      return t;
                  }, ct, TaskContinuationOptions.None, TaskScheduler.Default)
                  .Unwrap();
          }

          /// <summary>
          /// 実際の読み込み処理（versioning併用）
          /// </summary>
          private async Task LoadInternalAsync(CancellationToken ct)
          {
              // 現在の実行のバージョンを記録
              var currentVersion = Interlocked.Increment(ref _version);

              // 既存の処理をキャンセル
              _cts?.Cancel();
              _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);

              await _gate.WaitAsync(_cts.Token);
              try
              {
                  // versioning: 古い実行は結果を破棄
                  if (currentVersion != _version)
                  {
                      _logger.LogDebug("古い実行をスキップ: Version {Current} != {Latest}",
                          currentVersion, _version);
                      return;
                  }

                  await SetStateAsync(_state with { IsLoading = true, ErrorMessage = null });

                  // 実際のDB読み込み（重い処理）
                  using var scope = _scopeFactory.CreateScope();
                  var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();

                  var result = await mediator.Send(new Get{Entity}sQuery(), _cts.Token);

                  // 最新版のみ反映
                  if (currentVersion == _version && result.IsSuccess)
                  {
                      await SetStateAsync(_state with
                      {
                          IsLoading = false,
                          {Entity}s = result.Value?.ToImmutableList() ?? ImmutableList<{Entity}Dto>.Empty,
                          ErrorMessage = null
                      });
                  }
                  else if (result.IsSuccess == false)
                  {
                      await SetStateAsync(_state with
                      {
                          IsLoading = false,
                          ErrorMessage = result.Error
                      });
                  }
              }
              catch (OperationCanceledException)
              {
                  _logger.LogDebug("読み込み処理がキャンセルされました: Version {Version}", currentVersion);
              }
              catch (Exception ex)
              {
                  _logger.LogError(ex, "{Entity}一覧の読み込みに失敗しました");
                  await SetStateAsync(_state with
                  {
                      IsLoading = false,
                      ErrorMessage = "データの読み込みに失敗しました"
                  });
              }
              finally
              {
                  _gate.Release();
              }
          }

          private async Task SetStateAsync({Entity}{Operation}State newState)
          {
              _state = newState;

              if (OnChangeAsync is null) return;

              foreach (var handler in OnChangeAsync.GetInvocationList().Cast<Func<Task>>())
              {
                  try
                  {
                      await handler();
                  }
                  catch (Exception ex)
                  {
                      _logger.LogError(ex, "状態変更通知中にエラーが発生しました");
                  }
              }
          }

          public void Dispose()
          {
              _cts?.Cancel();
              _cts?.Dispose();
              _gate.Dispose();
          }
      }

example_usage: |
  // Component での使用例
  @page "/{entity}s/edit"
  @inject {Entity}EditStore Store
  @implements IDisposable

  <EditForm Model="@Store.GetState()">
      <InputText @bind-Value="@Store.GetState().Name"
                 @oninput="@(e => Store.UpdateField(s => s with { Name = e.Value?.ToString() ?? "" }))" />

      <button type="submit" disabled="@Store.GetState().IsLoading">
          保存
      </button>
  </EditForm>

  @code {
      protected override void OnInitialized()
      {
          Store.OnChangeAsync += StateHasChanged;
      }

      public void Dispose()
      {
          Store.OnChangeAsync -= StateHasChanged;
      }
  }

tests:
  - name: "UpdateField で状態が更新される"
    scenario: |
      Given: Store を初期化
      When: UpdateField で Name を更新
      Then: GetState().Name が更新され、IsDirty = true

  - name: "ExecuteAsync 成功時に IsLoading が false になる"
    scenario: |
      Given: Store を初期化
      When: ExecuteAsync を実行
      Then: 実行中は IsLoading = true、完了後は IsLoading = false

ai_guidance:
  when_to_use:
    - "フォームの状態管理が必要な場合"
    - "Command/Queryの送信とローディング状態の管理"
    - "複数のComponentで状態を共有したい場合"

  when_not_to_use:
    - "UI手順のオーケストレーション → PageActionsを使用"
    - "認証状態など、システムレベルの状態 → SessionProviderを使用"

  common_mistakes:
    - mistake: "Store に UI手順（確認ダイアログ、画面遷移）を実装する"
      solution: "UI手順はPageActionsに実装。StoreはI/Oと状態管理のみ"

    - mistake: "Stateをミュータブルに実装する"
      solution: "record型とwith式でイミュータブルに実装"

    - mistake: "MediatRを直接DIで受け取る"
      solution: "IServiceScopeFactoryを使ってスコープ管理"

evidence:
  implementation: "src/Application/Infrastructure/ProductCatalog/UI/Store/ProductsStore.cs"
  state: "src/Application/Infrastructure/ProductCatalog/UI/Store/ProductsState.cs"
  test_file: "未実装 - 今後の実装予定"

changelog:
  - version: 1.0.0
    date: 2025-11-05
    changes:
      - "初版リリース"
