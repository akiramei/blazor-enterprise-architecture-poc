id: transaction-behavior
version: 2.0.0
name: TransactionBehavior
category: pipeline-behavior
intent: Command を単一トランザクションで実行し、Outboxパターンでドメインイベントを管理
order_hint: 400
description: |
  ICommand を実装したリクエストを単一トランザクション内で実行します。
  Handler 内で例外が発生した場合は自動的にロールバックされます。
  ドメインイベントをOutboxテーブルに保存し、確実な配信を保証します。

  【重要】このBehaviorはBounded Context固有の実装です。
  各Bounded Contextは独自のDbContextとOutbox実装を持ちます。

wiring:
  service_registrations:
    - registration: "services.AddScoped(typeof(IPipelineBehavior<,>), typeof(TransactionBehavior<,>))"
      lifetime: "Scoped"
      note: "DbContextがScopedなので、BehaviorもScopedで登録"
  dependencies:
    nuget:
      - name: "Microsoft.EntityFrameworkCore"
        version: "^8.0.0"
        required: true
      - name: "MediatR"
        version: "^12.0.0"
        required: true
        note: "IPipelineBehavior<,>を提供"
    domain:
      - Shared.Domain.Outbox.OutboxMessage
      - Shared.Kernel.Entity

  blazor_wasm_notes:
    - "Blazor WebAssemblyではScopedとSingletonは同じ動作だが、Scopedで統一すること"
    - "DbContextに依存するサービスは必ずScopedで登録"

  lifetime_rules:
    - rule: "DbContextに依存するサービスはScopedで登録"
      reason: "DbContextがScopedなので、依存するサービスもScopedにしないとDIエラー"
    - rule: "TransactionBehaviorはBounded Context固有の実装"
      reason: "各Bounded Contextは独自のDbContextを持つため"

preconditions:
  - "{BoundedContext}DbContext が DbContext を継承している"
  - "ICommand インターフェースが定義されている"
  - "すべての Command が ICommand を実装している"
  - "OutboxMessages DbSet が定義されている"

implementation:
  file_path: "src/Application/Shared/ProductCatalog/Infrastructure/Persistence/Behaviors/TransactionBehavior.cs"
  namespace: "ProductCatalog.Shared.Infrastructure.Persistence.Behaviors"
  template: |
    using System.Text.Json;
    using MediatR;
    using Microsoft.EntityFrameworkCore;
    using Microsoft.Extensions.Logging;
    using Shared.Application;
    using Shared.Application.Interfaces;
    using Shared.Kernel;
    using Shared.Domain.Outbox;

    namespace ProductCatalog.Shared.Infrastructure.Persistence.Behaviors;

    /// <summary>
    /// トランザクション管理のPipeline Behavior（Command専用）
    ///
    /// 【トランザクショナルOutboxパターン】
    ///
    /// 責務:
    /// - ビジネスエンティティ更新とOutbox保存の原子性確保
    /// - ドメインイベントをOutboxに変換して永続化
    /// - トランザクション管理（コミット/ロールバック）
    ///
    /// 設計:
    /// - ProductCatalogDbContext使用（Product + Outbox物理同居）
    /// - 単一トランザクションで原子性確保
    /// - ネストトランザクション回避
    /// </summary>
    public sealed class TransactionBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
        where TRequest : ICommand<TResponse>
        where TResponse : Result
    {
        private readonly ProductCatalogDbContext _context;
        private readonly ILogger<TransactionBehavior<TRequest, TResponse>> _logger;

        public TransactionBehavior(
            ProductCatalogDbContext context,
            ILogger<TransactionBehavior<TRequest, TResponse>> logger)
        {
            _context = context;
            _logger = logger;
        }

        public async Task<TResponse> Handle(
            TRequest request,
            RequestHandlerDelegate<TResponse> next,
            CancellationToken cancellationToken)
        {
            // ネストされたトランザクションを防ぐため、既存トランザクションがあればスキップ
            if (_context.Database.CurrentTransaction != null)
            {
                return await next();
            }

            var commandName = typeof(TRequest).Name;

            _logger.LogDebug("トランザクション開始: {CommandName}", commandName);

            await using var transaction = await _context.Database.BeginTransactionAsync(cancellationToken);

            try
            {
                var response = await next();

                if (response.IsSuccess)
                {
                    // ドメインイベントをディスパッチ
                    await DispatchDomainEventsAsync(cancellationToken);

                    // Commit
                    await _context.SaveChangesAsync(cancellationToken);
                    await transaction.CommitAsync(cancellationToken);

                    _logger.LogDebug("トランザクションコミット: {CommandName}", commandName);
                }
                else
                {
                    // ビジネスルール違反の場合もロールバック
                    await transaction.RollbackAsync(cancellationToken);
                    _logger.LogDebug("トランザクションロールバック(ビジネスルール違反): {CommandName}", commandName);
                }

                return response;
            }
            catch (Exception ex)
            {
                await transaction.RollbackAsync(cancellationToken);
                _logger.LogError(ex, "トランザクションロールバック(例外): {CommandName}", commandName);
                throw;
            }
        }

        private async Task DispatchDomainEventsAsync(CancellationToken ct)
        {
            var domainEntities = _context.ChangeTracker
                .Entries<Entity>()
                .Where(x => x.Entity.GetDomainEvents().Any())
                .ToList();

            var domainEvents = domainEntities
                .SelectMany(x => x.Entity.GetDomainEvents())
                .ToList();

            domainEntities.ForEach(entity => entity.Entity.ClearDomainEvents());

            // Outbox Pattern: ドメインイベントをOutboxテーブルに保存
            // トランザクション内で保存するため、確実に配信される
            foreach (var domainEvent in domainEvents)
            {
                var eventType = domainEvent.GetType();
                var eventTypeName = eventType.Name;
                var eventContent = JsonSerializer.Serialize(domainEvent, eventType, new JsonSerializerOptions
                {
                    WriteIndented = false
                });

                var outboxMessage = OutboxMessage.Create(eventTypeName, eventContent);
                await _context.OutboxMessages.AddAsync(outboxMessage, ct);

                _logger.LogInformation(
                    "ドメインイベントをOutboxに保存: {EventType} [OutboxMessageId: {OutboxMessageId}]",
                    eventType,
                    outboxMessage.Id);
            }
        }
    }

example_usage: |
  // Command の定義（自動的にトランザクション内で実行される）
  public sealed record CreateProductCommand(
      string Name,
      string Description,
      decimal Price,
      int InitialStock
  ) : ICommand<Result<Guid>>
  {
      public string IdempotencyKey { get; init; } = Guid.NewGuid().ToString();
  }

  // Handler の実装
  public sealed class CreateProductHandler
      : IRequestHandler<CreateProductCommand, Result<Guid>>
  {
      private readonly IProductRepository _repository;

      public CreateProductHandler(IProductRepository repository)
      {
          _repository = repository;
      }

      public async Task<Result<Guid>> Handle(
          CreateProductCommand command,
          CancellationToken cancellationToken)
      {
          // この処理全体が TransactionBehavior によってトランザクション内で実行される
          var product = Product.Create(
              command.Name,
              command.Description,
              new Money(command.Price),
              command.InitialStock
          );

          await _repository.SaveAsync(product, cancellationToken);

          // SaveChangesAsync と Commit は TransactionBehavior が自動実行
          return Result.Success(product.Id.Value);
      }
  }

tests:
  - name: "例外発生時にロールバックされる"
    given: "Handler 内で例外が発生"
    when: "Command を実行"
    then: "データベースへの変更がロールバックされる"
    expect: "未コミット"

  - name: "Query にはトランザクションが適用されない"
    given: "IQuery を実装したリクエスト"
    when: "Query を実行"
    then: "TransactionBehavior がスキップされる"
    expect: "トランザクション未開始"

  - name: "正常終了時にコミットされる"
    given: "Handler が正常終了"
    when: "Command を実行"
    then: "データベースへの変更がコミットされる"
    expect: "コミット成功"

metrics:
  performance_impact: "中 (トランザクション開始/コミット: 5-10ms)"
  execution_order: 400

ai_guidance:
  when_to_use:
    - "データベースへの書き込みを伴う Command"
    - "複数テーブルへの変更を原子性を保って実行したい場合"
    - "ドメインイベントを確実に配信したい場合（Outboxパターン）"
    - "エラー時に自動ロールバックさせたい場合"

  when_not_to_use:
    - "Query (読み取り専用操作)"
    - "外部API呼び出しのみの処理"
    - "ファイルシステム操作"

  common_mistakes:
    - mistake: "Handler 内で SaveChangesAsync を呼び出す"
      description: "TransactionBehaviorがパイプラインで自動的にSaveChangesAsyncを呼ぶ"
      solution: "Handler内でSaveChangesAsyncを呼ばない。TransactionBehaviorに任せる"
      severity: "high"

    - mistake: "ネストしたトランザクションを開始しようとする"
      solution: "CurrentTransaction をチェックしてスキップする"
      severity: "medium"

    - mistake: "Query に ICommand を実装する"
      description: "ICommandを実装するとTransactionBehaviorが動作してしまう"
      solution: "Query は IQuery、Command は ICommand を実装する"
      severity: "high"

    - mistake: "Result.Fail時にドメインイベントが発行される"
      solution: "Success時のみドメインイベントをOutboxに保存"
      severity: "medium"

    - mistake: "Singleton/Scoped混在によるDIエラー"
      description: "DbContext(Scoped)に依存するサービスをSingletonで登録するとDIエラー"
      solution: "TransactionBehavior、DbContext、RepositoryはすべてScopedで登録"
      severity: "high"
      error_message: "Cannot consume scoped service from singleton"

    - mistake: "独自のトランザクション管理を実装"
      description: "このプロジェクトはTransactionBehaviorでトランザクションを管理している"
      solution: "TransactionBehaviorに任せる。独自のBeginTransaction/Commitは不要"
      severity: "critical"

  bounded_context_notes: |
    このBehaviorはBounded Context固有の実装です。

    現在の実装:
    - ProductCatalog: src/Application/Shared/ProductCatalog/Infrastructure/Persistence/Behaviors/TransactionBehavior.cs
    - PurchaseManagement: 同様の実装が存在（各Bounded Contextが独立）

    各Bounded Contextは独自のDbContextとOutbox実装を持ち、
    異なるデータベーススキーマやテーブル設計を持つ可能性があります。

changelog:
  - version: 2.0.0
    date: 2025-11-05
    changes:
      - "ネストしたトランザクションのチェック機能追加"
      - "ロギングの改善"

  - version: 1.5.0
    date: 2025-10-10
    changes:
      - "SaveChangesAsync の自動呼び出しを追加"

  - version: 1.0.0
    date: 2025-09-01
    changes:
      - "初版リリース"

evidence:
  implementation_file: "src/Application/Shared/ProductCatalog/Infrastructure/Persistence/Behaviors/TransactionBehavior.cs"
  test_file: "未実装 - 今後の実装予定"
  outbox_entity: "src/Shared/Domain/Outbox/OutboxMessage.cs"
