id: domain-typed-id
version: 1.0.0
name: Typed ID Value Object Pattern
category: domain-pattern
intent: 集約固有の強型付けIDで型安全性を確保し、ID取り違えを防止
description: |
  Guid をそのまま使用する代わりに、集約ごとに専用のID型を定義。
  コンパイル時に異なる集約のIDを取り違えることを防止。

  例: BookingId と RoomId は両方 Guid だが、型が異なるため
  メソッド引数で取り違えるとコンパイルエラーになる。

benefits:
  - "型安全性: BookingId と RoomId の取り違えをコンパイル時に検出"
  - "意図の明確化: メソッドシグネチャが自己文書化される"
  - "ファクトリ制御: ID生成ルールを一元管理"
  - "暗黙的変換: 必要に応じて Guid への変換を許可"

applicability:
  required_characteristics:
    - struct:typed-id
  recommended_for:
    - struct:single-aggregate
  typical_scenarios:
    - "型安全なエンティティID"
    - "集約ルートの識別"

implementation:
  file_path: "src/Domain/{BoundedContext}/{Aggregate}/{Entity}Id.cs"
  template: |
    using {Kernel.Namespace};

    namespace {BoundedContext}.Domain.{Aggregate};

    /// <summary>
    /// {Entity}ID（値オブジェクト）
    /// </summary>
    public sealed class {Entity}Id : ValueObject
    {
        public Guid Value { get; }

        public {Entity}Id(Guid value)
        {
            if (value == Guid.Empty)
                throw new ArgumentException("{Entity}IDは空にできません", nameof(value));
            Value = value;
        }

        /// <summary>
        /// 新しいIDを生成
        /// </summary>
        public static {Entity}Id New() => new(Guid.NewGuid());

        /// <summary>
        /// 既存のGuidからIDを生成
        /// </summary>
        public static {Entity}Id From(Guid value) => new(value);

        protected override IEnumerable<object?> GetEqualityComponents()
        {
            yield return Value;
        }

        /// <summary>
        /// Guidへの暗黙的変換（APIレスポンス等で便利）
        /// </summary>
        public static implicit operator Guid({Entity}Id id) => id.Value;

        public override string ToString() => Value.ToString();
    }

  ef_core_configuration: |
    // Entity Framework Core での設定例
    public class {Entity}Configuration : IEntityTypeConfiguration<{Entity}>
    {
        public void Configure(EntityTypeBuilder<{Entity}> builder)
        {
            builder.HasKey(e => e.Id);

            builder.Property(e => e.Id)
                .HasConversion(
                    id => id.Value,           // {Entity}Id → Guid
                    value => {Entity}Id.From(value))  // Guid → {Entity}Id
                .IsRequired();
        }
    }

# ============================================================================
# EF Core 詳細設定（★追加セクション）
# ============================================================================

efcore_detailed_configuration:
  description: |
    TypedIdをEF Coreで使用する際の詳細な設定ガイド。
    フィードバックに基づき追加されたセクション。

  record_struct_version:
    description: "C# 10以降で推奨される record struct バージョン"
    template: |
      /// <summary>
      /// {Entity}ID（record struct版 - 軽量・高速）
      /// </summary>
      public readonly record struct {Entity}Id(Guid Value)
      {
          public static {Entity}Id NewId() => new(Guid.NewGuid());
          public static {Entity}Id From(Guid value) => new(value);

          // record struct は自動的に Equals/GetHashCode を生成
      }

      // EF Core Configuration
      builder.Property(e => e.Id)
          .HasConversion(
              id => id.Value,
              value => new {Entity}Id(value));  // record struct のコンストラクタ呼び出し

  multiple_typed_ids:
    description: "複数のTypedIdを持つEntityの設定例"
    template: |
      // Entity: Loan（貸出）
      public class Loan : Entity<LoanId>
      {
          public BookId BookId { get; private set; }
          public MemberId MemberId { get; private set; }
          public CopyId CopyId { get; private set; }
          // ...
      }

      // Configuration
      public class LoanConfiguration : IEntityTypeConfiguration<Loan>
      {
          public void Configure(EntityTypeBuilder<Loan> builder)
          {
              builder.HasKey(e => e.Id);

              // 主キー
              builder.Property(e => e.Id)
                  .HasConversion(id => id.Value, value => LoanId.From(value));

              // 外部キー（それぞれ変換が必要）
              builder.Property(e => e.BookId)
                  .HasConversion(id => id.Value, value => BookId.From(value));

              builder.Property(e => e.MemberId)
                  .HasConversion(id => id.Value, value => MemberId.From(value));

              builder.Property(e => e.CopyId)
                  .HasConversion(id => id.Value, value => CopyId.From(value));

              // リレーション設定
              builder.HasOne<Book>()
                  .WithMany()
                  .HasForeignKey(e => e.BookId);

              builder.HasOne<Member>()
                  .WithMany()
                  .HasForeignKey(e => e.MemberId);
          }
      }

  linq_query_notes:
    description: "LINQ クエリでの注意点"
    content: |
      【重要】TypedId の LINQ クエリでの比較

      ❌ 禁止: .Value プロパティでの比較
      ```csharp
      // EF Core がSQLに変換できない
      var book = await _dbContext.Books
          .Where(b => b.Id.Value == requestGuid)  // エラー
          .FirstOrDefaultAsync();
      ```

      ✅ 正しい: TypedId インスタンスでの比較
      ```csharp
      var bookId = BookId.From(requestGuid);
      var book = await _dbContext.Books
          .Where(b => b.Id == bookId)  // OK - HasConversion が適用される
          .FirstOrDefaultAsync();
      ```

      ✅ 外部キーも同様
      ```csharp
      var memberId = MemberId.From(request.MemberId);
      var loans = await _dbContext.Loans
          .Where(l => l.MemberId == memberId)
          .ToListAsync();
      ```

  value_comparer_for_collections:
    description: "コレクションやインデックスでの ValueComparer 設定"
    template: |
      // コレクション内でのTypedId比較を最適化
      builder.Property(e => e.Id)
          .HasConversion(
              id => id.Value,
              value => {Entity}Id.From(value))
          .Metadata.SetValueComparer(
              new ValueComparer<{Entity}Id>(
                  (a, b) => a.Value == b.Value,
                  id => id.Value.GetHashCode(),
                  id => {Entity}Id.From(id.Value)));

  migration_notes:
    description: "マイグレーション時の注意"
    content: |
      【注意】既存のGuid列をTypedIdに変更する場合

      1. TypedIdの変換設定は「コード上の型」のみ変更
      2. データベース列の型（uniqueidentifier/uuid）は変わらない
      3. したがって、追加のマイグレーションは不要

      既存データはそのまま使用可能：
      - DB: uniqueidentifier 列 → 変更なし
      - C#: Guid → TypedId に変更
      - HasConversion で相互変換

example_usage: |
  // 型安全な引数
  public async Task<Booking?> GetBookingForRoom(
      BookingId bookingId,  // ← RoomId を渡すとコンパイルエラー
      RoomId roomId,        // ← BookingId を渡すとコンパイルエラー
      CancellationToken ct)
  {
      var booking = await _repository.GetByIdAsync(bookingId, ct);
      if (booking?.RoomId != roomId)
          return null;
      return booking;
  }

  // ファクトリでの新規ID生成
  public static Booking Create(
      RoomId roomId,
      string title,
      TimeSlot timeSlot)
  {
      return new Booking(
          BookingId.New(),  // 新しいID生成
          roomId,
          title,
          timeSlot);
  }

  // Command から ID 変換
  public async Task<Result<BookingDto>> Handle(
      GetBookingByIdQuery query,
      CancellationToken ct)
  {
      var bookingId = BookingId.From(query.BookingId);  // Guid → BookingId
      var booking = await _repository.GetByIdAsync(bookingId, ct);
      // ...
  }

  // API レスポンスでの暗黙的変換
  public record BookingCreatedResponse(Guid BookingId);

  return new BookingCreatedResponse(booking.Id);  // BookingId → Guid（暗黙的）

comparison:
  without_typed_id: |
    // 型安全でない例（Guid直接使用）
    public async Task UpdateBooking(
        Guid bookingId,
        Guid roomId,
        Guid organizerId)
    {
        // bookingId と roomId を間違えてもコンパイルが通る！
    }

  with_typed_id: |
    // 型安全な例（Typed ID使用）
    public async Task UpdateBooking(
        BookingId bookingId,
        RoomId roomId,
        UserId organizerId)
    {
        // 型が異なるため、間違えるとコンパイルエラー
    }

ai_guidance:
  when_to_use:
    - "複数の集約があり、IDの取り違えリスクがある場合"
    - "メソッドシグネチャを自己文書化したい場合"
    - "ID生成ルール（例：プレフィックス付き）を統一したい場合"
    - "DDD で集約の境界を明確にしたい場合"

  when_not_to_use:
    - "単一の集約しかない小規模プロジェクト"
    - "外部APIとの互換性で Guid を強制される場合"
    - "過度な抽象化を避けたい場合"

  common_mistakes:
    - mistake: "Guid.Empty を許可する"
      solution: "コンストラクタで Guid.Empty をチェックし例外をスロー"
      severity: "medium"

    - mistake: "暗黙的変換を双方向にする"
      solution: "Guid → TypedId は明示的（From メソッド）、TypedId → Guid のみ暗黙的"
      severity: "low"

    - mistake: "EF Core の変換設定を忘れる"
      solution: "HasConversion でマッピングを設定"
      severity: "high"

related_patterns:
  - id: "aggregate-root"
    relationship: "used-by"
    description: "集約ルートのIDとして使用"
  - id: "domain-timeslot"
    relationship: "sibling"
    description: "同じく値オブジェクトパターン"

changelog:
  - version: 1.0.0
    date: 2025-11-25
    changes:
      - "初版リリース"
      - "Reserve（会議室予約システム）からパターン抽出"

evidence:
  reference_implementation: "Reserve: src/Domain/RoomReservation/Bookings/BookingId.cs"
  another_example: "Reserve: src/Domain/RoomReservation/Rooms/RoomId.cs"
