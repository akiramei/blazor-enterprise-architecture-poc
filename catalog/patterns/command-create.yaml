id: command-create
version: 1.0.0
name: CreateCommand Pattern
category: command-pattern
intent: 新規エンティティ作成コマンドのテンプレート
description: |
  ドメインファクトリメソッドを使用して新規エンティティを作成するパターン。
  検証、認可、トランザクション、冪等性が自動的に適用されます。

dependencies:
  patterns:
    - validation-behavior
    - transaction-behavior
    - idempotency-behavior
  nuget:
    - name: "MediatR"
      version: "^12.0.0"
      required: true
      note: "Command/Handlerの基盤。IRequest<T>とIRequestHandler<,>を提供"
    - name: "FluentValidation"
      version: "^11.0.0"
      required: true
    - name: "FluentValidation.DependencyInjectionExtensions"
      version: "^11.0.0"
      required: true
      note: "AddValidatorsFromAssembly()を提供"

wiring:
  service_registrations:
    - registration: |
        services.AddMediatR(cfg =>
        {
            cfg.RegisterServicesFromAssembly(typeof(Program).Assembly);
            cfg.AddOpenBehavior(typeof(ValidationBehavior<,>));
            cfg.AddOpenBehavior(typeof(TransactionBehavior<,>));
        });
      lifetime: "Scoped"
      note: "MediatRとPipeline Behaviorsの登録"
    - registration: "services.AddValidatorsFromAssembly(typeof(Program).Assembly)"
      note: "FluentValidationのValidator自動登録"

  blazor_wasm_notes:
    - "Blazor WebAssemblyではScopedとSingletonは同じ動作だが、Scopedで統一すること"
    - "MediatRに依存するサービスは必ずScopedで登録"

  lifetime_rules:
    - rule: "CommandHandler、Repository、DbContextはすべてScopedで登録"
      reason: "MediatRがScopedなので、依存するサービスもScopedにしないとDIエラー"
    - rule: "SingletonでMediatRを使うサービスを登録しない"
      reason: "Cannot consume scoped service from singletonエラーが発生"

implementation:
  file_path: "src/Application/Features/Create{Entity}/Create{Entity}Command.cs"
  template: |
    using Shared.Application;
    using Shared.Application.Interfaces;

    namespace Application.Features.Create{Entity};

    /// <summary>
    /// {Entity}作成Command
    /// </summary>
    public class Create{Entity}Command : ICommand<Result<Guid>>
    {
        public string Name { get; init; } = string.Empty;
        public string Description { get; init; } = string.Empty;
        public decimal Price { get; init; }
        public string Currency { get; init; } = "JPY";
        public int InitialStock { get; init; }

        /// <summary>
        /// 冪等性キー（重複実行防止）
        /// </summary>
        public string IdempotencyKey { get; init; } = Guid.NewGuid().ToString();
    }

    // Validator 定義
    public sealed class Create{Entity}Validator : AbstractValidator<Create{Entity}Command>
    {
        public Create{Entity}Validator()
        {
            RuleFor(x => x.Name)
                .NotEmpty().WithMessage("{Entity}名は必須です")
                .MaximumLength(200).WithMessage("{Entity}名は200文字以内です");

            RuleFor(x => x.Description)
                .MaximumLength(2000).WithMessage("説明は2000文字以内です");

            RuleFor(x => x.Price)
                .GreaterThan(0).WithMessage("価格は0より大きい値を指定してください");

            RuleFor(x => x.InitialStock)
                .GreaterThanOrEqualTo(0).WithMessage("在庫数は0以上を指定してください");
        }
    }

    // Handler 実装
    /// <summary>
    /// {Entity}作成コマンドハンドラー (工業製品化版)
    ///
    /// 【処理フロー】
    /// 1. Domainのファクトリメソッド経由で集約を作成
    /// 2. Repository経由で保存
    /// 3. 作成されたIDを返す
    ///
    /// 【実装ガイド】
    /// - ファクトリメソッド（{Entity}.Create()）経由で作成
    /// - ビジネスルールはDomain層のファクトリメソッド内で検証
    /// - Handler内では取得・保存のオーケストレーションのみ
    /// - DomainExceptionは CommandPipeline.Handle() で Result.Fail に変換される
    /// </summary>
    public class Create{Entity}CommandHandler
        : CommandPipeline<Create{Entity}Command, Guid>
    {
        private readonly I{Entity}Repository _repository;

        public Create{Entity}CommandHandler(I{Entity}Repository repository)
        {
            _repository = repository;
        }

        protected override async Task<Result<Guid>> ExecuteAsync(
            Create{Entity}Command cmd,
            CancellationToken ct)
        {
            // 1. ファクトリメソッド経由で集約を作成
            // （ビジネスルールの検証はDomain層で行われる）
            // DomainExceptionは CommandPipeline.Handle() で Result.Fail に変換される
            var price = new Money(cmd.Price, cmd.Currency);
            var entity = {Entity}.Create(
                cmd.Name,
                cmd.Description,
                price,
                cmd.InitialStock);

            // 2. Repository経由で保存
            await _repository.SaveAsync(entity, ct);

            // 3. 作成されたIDを返す（後続処理で使用可能）
            return Result.Success(entity.Id.Value);
        }
    }

example_usage: |
  // UI から使用
  public sealed class ProductCreateActions
  {
      private readonly IMediator _mediator;
      private readonly IToastService _toast;
      private readonly NavigationManager _navigation;
      private readonly string _idempotencyKey = Guid.NewGuid().ToString();

      public async Task CreateAsync(ProductCreateForm form, CancellationToken ct)
      {
          var command = new CreateProductCommand(
              Name: form.Name,
              Description: form.Description,
              Price: form.Price,
              InitialStock: form.Stock
          )
          {
              IdempotencyKey = _idempotencyKey
          };

          var result = await _mediator.Send(command, ct);

          if (result.IsSuccess)
          {
              _toast.Success("商品を作成しました");
              _navigation.NavigateTo($"/products/{result.Value}");
          }
          else
          {
              _toast.Error(result.ErrorMessage);
          }
      }
  }

file_structure: |
  src/Application/Features/Create{Entity}/
  ├── Create{Entity}Command.cs       # Command定義 + Handler実装 + Validator

  src/Domain/{BoundedContext}/{Entity}s/
  └── {Entity}.cs                    # Domain Entity with factory method

  src/Application/Core/Commands/
  └── CommandPipeline.cs             # Base class for command handlers

tests:
  - name: "正常に作成できる"
    given: "正常な入力パラメータ"
    when: "Create{Entity}Command を実行"
    then: "エンティティが作成され、IDが返される"
    expect: "作成成功"

  - name: "未入力でエラー"
    given: "Name が空文字列"
    when: "Create{Entity}Command を実行"
    then: "ValidationBehavior がエラーを返す"
    expect: "検証エラー"

  - name: "同じ IdempotencyKey で2回実行しても1回だけ作成"
    given: "同じ IdempotencyKey を持つ2つの Command"
    when: "連続して実行"
    then: "1回目は作成され、2回目はキャッシュから返される"
    expect: "重複防止"

  - name: "例外発生時にロールバック"
    given: "Repository.SaveAsync が例外を投げる"
    when: "Create{Entity}Command を実行"
    then: "TransactionBehavior がロールバックする"
    expect: "ロールバック"

ai_guidance:
  when_to_use:
    - "新規エンティティの作成"
    - "ドメインファクトリメソッドで初期化したい場合"
    - "重複作成を防ぎたい場合"

  when_not_to_use:
    - "既存エンティティの更新 → UpdateCommand を使用"
    - "一括作成 → BulkCreateCommand を使用"

  common_mistakes:
    - mistake: "独自のCQRS/Mediator実装を作成"
      description: "このプロジェクトはMediatRを使用しており、独自のCommand/Handler基盤は不要"
      solution: "MediatRのIRequest<T>とIRequestHandler<TRequest, TResponse>を使用"
      severity: "critical"

    - mistake: "ドメインロジックを Handler に書く"
      solution: "ビジネスルールは Domain/{Entity}.cs に実装"
      severity: "medium"

    - mistake: "SaveChangesAsync を呼び出す"
      description: "TransactionBehaviorがパイプラインで自動的にSaveChangesAsyncを呼ぶ"
      solution: "Handler内でSaveChangesAsyncを呼ばない。TransactionBehaviorに任せる"
      severity: "high"

    - mistake: "IdempotencyKey を毎回新しく生成する"
      solution: "画面表示時に1回だけ生成し、再試行時は同じ値を使う"
      severity: "medium"

    - mistake: "作成後にキャッシュをクリアしない"
      solution: "一覧画面のキャッシュを無効化する（Create後にStore.LoadAsync()を呼ぶ）"
      severity: "low"

    - mistake: "Singleton/Scoped混在によるDIエラー"
      description: "MediatR(Scoped)に依存するサービスをSingletonで登録するとDIエラー"
      solution: "CommandHandler、Repository、DbContextはすべてScopedで登録"
      severity: "high"
      error_message: "Cannot consume scoped service from singleton"

    - mistake: "HandleAsyncメソッド名を使用"
      description: "MediatRのIRequestHandlerはHandleメソッド（Asyncなし）"
      solution: "Task<T> Handle(TRequest request, CancellationToken cancellationToken) を使用"
      severity: "medium"

    - mistake: "MediatRパッケージをインストールせずにCommand作成"
      description: "IRequest<T>、IRequestHandler<,>はMediatRパッケージに含まれる"
      solution: "dotnet add package MediatR"
      severity: "critical"

    - mistake: "Program.csでMediatRを登録し忘れる"
      description: "MediatRは明示的にDI登録が必要"
      solution: "services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly))"
      severity: "critical"

performance:
  typical_duration: "20-50ms"
  bottleneck: "データベース書き込み"

pipeline_execution_order: |
  1. MetricsBehavior (order: 50)
  2. ValidationBehavior (order: 100)
  3. AuthorizationBehavior (order: 200) - 属性があれば
  4. IdempotencyBehavior (order: 300)
  5. TransactionBehavior (order: 400)
  6. Handler 実行
  7. LoggingBehavior (order: 600)

changelog:
  - version: 1.0.0
    date: 2025-11-05
    changes:
      - "初版リリース"

evidence:
  command: "src/Application/Features/CreateProduct/CreateProductCommand.cs"
  handler: "src/Application/Features/CreateProduct/CreateProductCommandHandler.cs"
  validator: "未実装 - FluentValidationは使用していない"
  domain_entity: "src/Domain/ProductCatalog/Products/Product.cs"
  repository_interface: "src/Domain/ProductCatalog/Products/IProductRepository.cs"
  repository_implementation: "src/Application/Infrastructure/ProductCatalog/Infrastructure/Persistence/Repositories/EfProductRepository.cs"
