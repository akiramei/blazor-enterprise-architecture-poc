id: authorization-behavior
version: 1.2.1
name: AuthorizationBehavior
category: pipeline-behavior
intent: ロールベースおよびポリシーベース認可チェックを MediatR パイプラインで自動実行
order_hint: 200
description: |
  Command/Query に [Authorize] 属性が付いている場合、
  現在のユーザーが必要なロールまたはポリシーを持っているかをチェックします。
  権限がない場合は Result.Fail を返します。
  ASP.NET Core標準のIAuthorizationServiceとポリシーベース認可に対応。

wiring:
  service_registrations:
    - "services.AddScoped(typeof(IPipelineBehavior<,>), typeof(AuthorizationBehavior<,>))"
  dependencies:
    nuget:
      - Microsoft.AspNetCore.Authorization: "^8.0.0"

preconditions:
  - "ICurrentUserService が DI 登録されている"
  - "IAuthorizationService が DI 登録されている"
  - "認証ミドルウェアが有効"
  - "[Authorize] 属性が定義されている (Shared.Application.Attributes)"

implementation:
  file_path: "src/Shared/Infrastructure/Behaviors/AuthorizationBehavior.cs"
  namespace: "Shared.Infrastructure.Behaviors"
  template: |
    using MediatR;
    using Microsoft.AspNetCore.Authorization;
    using Microsoft.Extensions.Logging;
    using Shared.Application;
    using Shared.Application.Interfaces;
    using AuthorizeAttribute = Shared.Application.Attributes.AuthorizeAttribute;

    namespace Shared.Infrastructure.Behaviors;

    /// <summary>
    /// 認可のPipeline Behavior
    /// Command/Queryの認可属性をチェック
    /// </summary>
    public sealed class AuthorizationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
        where TRequest : IRequest<TResponse>
        where TResponse : Result
    {
        private readonly ICurrentUserService _currentUser;
        private readonly IAuthorizationService _authorizationService;
        private readonly ILogger<AuthorizationBehavior<TRequest, TResponse>> _logger;

        public AuthorizationBehavior(
            ICurrentUserService currentUser,
            IAuthorizationService authorizationService,
            ILogger<AuthorizationBehavior<TRequest, TResponse>> logger)
        {
            _currentUser = currentUser;
            _authorizationService = authorizationService;
            _logger = logger;
        }

        public async Task<TResponse> Handle(
            TRequest request,
            RequestHandlerDelegate<TResponse> next,
            CancellationToken cancellationToken)
        {
            // リクエストに必要な権限を取得
            var authorizeAttributes = request.GetType()
                .GetCustomAttributes(typeof(AuthorizeAttribute), true)
                .Cast<AuthorizeAttribute>()
                .ToList();

            if (!authorizeAttributes.Any())
            {
                return await next();  // 認可不要
            }

            // 認証チェック
            if (!_currentUser.IsAuthenticated)
            {
                _logger.LogWarning("未認証ユーザーがアクセスを試みました: {RequestType}", typeof(TRequest).Name);
                return (TResponse)(object)Result.Fail("認証が必要です");
            }

            // 権限チェック
            foreach (var attribute in authorizeAttributes)
            {
                // ポリシーベースの認可
                if (!string.IsNullOrEmpty(attribute.Policy))
                {
                    if (_currentUser.User == null)
                    {
                        return (TResponse)(object)Result.Fail("認証が必要です");
                    }

                    var authorized = await _authorizationService.AuthorizeAsync(
                        _currentUser.User,
                        attribute.Policy);

                    if (!authorized.Succeeded)
                    {
                        _logger.LogWarning(
                            "ポリシー認可失敗: {Policy} ユーザー: {UserName}",
                            attribute.Policy,
                            _currentUser.UserName);
                        return (TResponse)(object)Result.Fail("この操作を実行する権限がありません");
                    }
                }

                // ロールベースの認可
                if (!string.IsNullOrEmpty(attribute.Roles))
                {
                    var roles = attribute.Roles.Split(',');
                    var hasRole = roles.Any(role => _currentUser.IsInRole(role.Trim()));

                    if (!hasRole)
                    {
                        _logger.LogWarning(
                            "ロール認可失敗: 必要なロール={Roles} ユーザー={UserName}",
                            attribute.Roles,
                            _currentUser.UserName);
                        return (TResponse)(object)Result.Fail($"必要なロール: {attribute.Roles}");
                    }
                }
            }

            return await next();
        }
    }

example_usage: |
  // Admin ロールが必要な Command
  [Authorize(Roles = "Admin")]
  public sealed record DeleteProductCommand(Guid ProductId)
      : ICommand<Result>
  {
      public string IdempotencyKey { get; init; } = Guid.NewGuid().ToString();
  }

  // Admin または Manager ロールが必要な Command
  [Authorize(Roles = "Admin,Manager")]
  public sealed record BulkUpdateProductPricesCommand(
      IReadOnlyList<ProductPriceUpdate> Updates
  ) : ICommand<Result<BulkOperationResult>>
  {
      public string IdempotencyKey { get; init; } = Guid.NewGuid().ToString();
  }

  // ポリシーベース認可
  [Authorize(Policy = "CanManageProducts")]
  public sealed record UpdateProductCommand(
      Guid ProductId,
      string Name,
      decimal Price
  ) : ICommand<Result>;

  // ロール制限なし（すべての認証済みユーザーが実行可能）
  public sealed record GetProductsQuery()
      : IQuery<Result<IEnumerable<ProductDto>>>;

tests:
  - name: "必要なロールを持つユーザーは通過"
    given: "User が Admin ロールを持つ"
    when: "[RequireRole('Admin')] が付いた Command を実行"
    then: "Handler が実行される"
    expect: "認可成功"

  - name: "ロールを持たないユーザーは拒否"
    given: "User が一般ユーザー"
    when: "[RequireRole('Admin')] が付いた Command を実行"
    then: "Result.Fail('権限がありません') が返される"
    expect: "認可失敗"

  - name: "未認証ユーザーは拒否"
    given: "未認証ユーザー"
    when: "[RequireRole('Admin')] が付いた Command を実行"
    then: "Result.Fail('権限がありません') が返される"
    expect: "認可失敗"

  - name: "属性なしの場合はスキップ"
    given: "User が一般ユーザー"
    when: "属性なしの Query を実行"
    then: "認可チェックがスキップされ Handler が実行される"
    expect: "スキップ"

metrics:
  performance_impact: "極低 (通常 < 1ms)"
  execution_order: 200

ai_guidance:
  when_to_use:
    - "管理者専用の Command（削除、一括更新など）"
    - "特定のロールのみ実行可能な処理"
    - "部門管理者、システム管理者などの階層的な権限管理"

  when_not_to_use:
    - "データレベルの権限（所有者のみ編集可能など）→ Handler 内で実装"
    - "認証チェック（認証ミドルウェアで実装）"
    - "属性ベースの複雑な認可（ASP.NET Core の Policy を使用）"

  common_mistakes:
    - mistake: "[RequireRole] をつけ忘れる"
      solution: "削除・更新系 Command には必ず付ける習慣をつける"

    - mistake: "データレベル認可を AuthorizationBehavior で実装しようとする"
      solution: "データレベル認可は Handler 内で実装（例: product.OwnerId == userId）"

    - mistake: "IHttpContextAccessor を DI 登録し忘れる"
      solution: "Program.cs で services.AddHttpContextAccessor() を呼び出す"

changelog:
  - version: 1.2.1
    date: 2025-11-05
    changes:
      - "ロギングメッセージの改善"
      - "複数ロール対応の OR 条件を明示"

  - version: 1.2.0
    date: 2025-10-15
    changes:
      - "複数ロール指定のサポート（OR条件）"

  - version: 1.0.0
    date: 2025-09-01
    changes:
      - "初版リリース"

evidence:
  implementation_file: "src/Shared/Infrastructure/Behaviors/AuthorizationBehavior.cs"
  example_command: "src/Application/Features/DeleteProduct/DeleteProductCommand.cs"
  attribute_definition: "src/Shared/Application/Attributes/AuthorizeAttribute.cs"
