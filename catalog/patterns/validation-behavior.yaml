id: validation-behavior
version: 1.3.0
name: ValidationBehavior
category: pipeline-behavior
intent: FluentValidation による入力検証を MediatR パイプラインで自動実行
order_hint: 100
description: |
  Command/Query の実行前に FluentValidation を使用して入力検証を行います。
  検証エラーがある場合は Result.Fail を返し、処理を中断します。

wiring:
  service_registrations:
    - registration: "services.AddScoped(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>))"
      lifetime: "Scoped"
      note: "MediatRパイプラインはScopedなので、BehaviorもScopedで登録"
  dependencies:
    nuget:
      - name: "FluentValidation"
        version: "^11.0.0"
        required: true
      - name: "FluentValidation.DependencyInjectionExtensions"
        version: "^11.0.0"
        required: true
      - name: "MediatR"
        version: "^12.0.0"
        required: true
        note: "ValidationBehaviorはMediatRのIPipelineBehaviorを実装"
    assembly_scanner:
      - "services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly())"

  blazor_wasm_notes:
    - "Blazor WebAssemblyではScopedとSingletonは同じ動作だが、Scopedで統一すること"
    - "MediatRに依存するサービスは必ずScopedで登録"

  lifetime_rules:
    - rule: "MediatRに依存するサービスはScopedで登録"
      reason: "MediatRがScopedなので、依存するサービスもScopedにしないとDIエラー"
    - rule: "ValidatorはAddValidatorsFromAssemblyで自動登録"
      reason: "手動登録は漏れの原因になる"

preconditions:
  - "FluentValidation がインストールされている"
  - "Validator クラスが AbstractValidator<T> を継承している"
  - "Result 型が定義されている"

applicability:
  always_apply: true
  reason: "入力検証は全てのCommand/Queryで必要"
  required_characteristics: []
  recommended_for:
    - op:mutates-state
  optional_for:
    - op:read-only

implementation:
  file_path: "src/Shared/Infrastructure/Behaviors/ValidationBehavior.cs"
  namespace: "Shared.Infrastructure.Behaviors"
  template: |
    using FluentValidation;
    using MediatR;
    using Shared.Application;

    namespace Shared.Infrastructure.Behaviors;

    /// <summary>
    /// バリデーションのPipeline Behavior
    /// FluentValidationを使用してリクエストを検証
    /// </summary>
    public sealed class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
        where TRequest : IRequest<TResponse>
        where TResponse : Result
    {
        private readonly IEnumerable<IValidator<TRequest>> _validators;

        public ValidationBehavior(IEnumerable<IValidator<TRequest>> validators)
        {
            _validators = validators;
        }

        public async Task<TResponse> Handle(
            TRequest request,
            RequestHandlerDelegate<TResponse> next,
            CancellationToken cancellationToken)
        {
            if (!_validators.Any())
            {
                return await next();
            }

            var context = new ValidationContext<TRequest>(request);

            var validationResults = await Task.WhenAll(
                _validators.Select(v => v.ValidateAsync(context, cancellationToken)));

            var failures = validationResults
                .SelectMany(r => r.Errors)
                .Where(f => f != null)
                .ToList();

            if (failures.Any())
            {
                var errorMessage = string.Join("; ", failures.Select(f => f.ErrorMessage));

                // Result型にエラーを設定して返す
                return (TResponse)(object)Result.Fail(errorMessage);
            }

            return await next();
        }
    }

example_usage: |
  // Validator の定義
  public sealed class CreateProductValidator : AbstractValidator<CreateProductCommand>
  {
      public CreateProductValidator()
      {
          RuleFor(x => x.Name)
              .NotEmpty().WithMessage("商品名は必須です")
              .MaximumLength(200).WithMessage("商品名は200文字以内です");

          RuleFor(x => x.Price)
              .GreaterThan(0).WithMessage("価格は0より大きい値を指定してください");

          RuleFor(x => x.InitialStock)
              .GreaterThanOrEqualTo(0).WithMessage("在庫数は0以上を指定してください");
      }
  }

  // Command 実装（Validator が自動実行される）
  public sealed record CreateProductCommand(
      string Name,
      string Description,
      decimal Price,
      int InitialStock
  ) : ICommand<Result<Guid>>;

tests:
  - name: "未入力で検証エラーが返される"
    given: "Name が空文字列"
    when: "CreateProductCommand を実行"
    then: "Result.IsSuccess == false かつ エラーメッセージに '商品名は必須です' が含まれる"
    expect: "検証エラー"

  - name: "正常な入力で次の処理に進む"
    given: "すべてのフィールドが正常"
    when: "CreateProductCommand を実行"
    then: "Handler が実行され、Result.IsSuccess == true"
    expect: "検証通過"

metrics:
  performance_impact: "低 (通常 1-5ms)"
  execution_order: 100

ai_guidance:
  when_to_use:
    - "Command の入力検証が必要な場合"
    - "Query のパラメータ検証が必要な場合"
    - "複雑な検証ルール（複数フィールドの相関チェック）を実装したい場合"

  when_not_to_use:
    - "ドメインロジック内のビジネスルール検証（Domainに実装すべき）"
    - "認可チェック（AuthorizationBehaviorを使用）"

  common_mistakes:
    - mistake: "Validator を DI 登録し忘れる"
      solution: "services.AddValidatorsFromAssembly() を呼び出す"
      severity: "high"

    - mistake: "Result 型以外の戻り値を使う"
      solution: "すべての Command/Query は Result または Result<T> を返す"
      severity: "high"

    - mistake: "Singleton/Scoped混在によるDIエラー"
      description: "MediatR(Scoped)に依存するサービスをSingletonで登録するとDIエラー"
      solution: "すべてScopedに統一する"
      severity: "high"
      error_message: "Cannot consume scoped service from singleton"

    - mistake: "HandleAsyncメソッド名を使用"
      description: "MediatRのIRequestHandlerはHandleメソッド（Asyncなし）"
      solution: "Task<T> Handle(TRequest request, CancellationToken cancellationToken) を使用"
      severity: "medium"

    - mistake: "独自のCQRS/Mediator実装を作成"
      description: "このプロジェクトはMediatRを使用しており、独自実装は不要"
      solution: "MediatRのIRequest<T>とIRequestHandler<TRequest, TResponse>を使用"
      severity: "critical"

    - mistake: "FluentValidationをインストールせずにValidator作成"
      description: "AbstractValidator<T>はFluentValidationパッケージに含まれる"
      solution: "dotnet add package FluentValidation.DependencyInjectionExtensions"
      severity: "high"

changelog:
  - version: 1.3.0
    date: 2025-11-05
    changes:
      - "Result 型への対応を強化"
      - "エラーメッセージのフォーマット改善"

  - version: 1.2.0
    date: 2025-10-01
    changes:
      - "非同期検証のサポート追加"

  - version: 1.0.0
    date: 2025-09-01
    changes:
      - "初版リリース"

evidence:
  implementation_file: "src/Shared/Infrastructure/Behaviors/ValidationBehavior.cs"
  example_command: "src/Application/Features/CreateProduct/CreateProductCommand.cs"
