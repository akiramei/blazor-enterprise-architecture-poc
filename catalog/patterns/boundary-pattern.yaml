id: boundary-pattern
version: 2.0.0
name: Boundary Pattern (Intent-Boundary分離)
category: domain-pattern
intent: ユーザーとシステムの接点（操作可否判定）をドメイン層に配置し、UIから業務ルールを分離する
description: |
  Boundaryパターンにより、「誰が・何に対して・何をできるか」の判定ロジックをドメイン層に集約する。
  UIは見た目と操作（プレゼンテーション）のみを担当し、Boundaryの判定結果を表示するだけの役割に徹する。

  古典的DDDではBoundaryはApplication層またはInfrastructure層に配置されるが、
  本パターンでは「操作可否判定」がビジネスルールであることを重視し、Domain層に配置する。

  【重要】業務ロジックはEntityが持つ
  BoundaryServiceは「データ取得」と「Entityへの委譲」のみを行う。
  業務ルールの判定（if文による状態チェック等）はEntity.CanXxx()メソッドに実装する。

scope: domain-pattern
layers:
  - domain

applicability:
  required_characteristics:
    - layer:ui
  recommended_for:
    - op:mutates-state
  typical_scenarios:
    - "操作可否判定"
    - "Entity.CanXxx()パターン"
    - "UIからの操作制御"

# ============================================================================
# Robustness Analysis との対応
# ============================================================================
robustness_mapping:
  description: |
    Robustness Analysis（堅牢性分析）の成果物と実装先の対応表

  table: |
    | 分析モデル | 実装先 | 責務 |
    |-----------|--------|------|
    | Boundary | IBoundary (Domain) | 画面契約の定義 |
    | Boundary | BoundaryService (Application/Infrastructure) | データ取得・ViewModel構築 |
    | Control | Entity.CanXxx() | 業務ルール判定（状態ベース） |
    | Control | Domain Service | 複数集約にまたがる判定 |
    | Entity | Entity | 状態と振る舞い |

  critical_rule: |
    ⚠️ 重要: Control の業務ロジックは Entity または Domain Service に実装する。
    BoundaryService は Control ではない。BoundaryService に業務ロジックを書いてはならない。

ai_selection_hints:
  trigger_phrases:
    - "操作可否"
    - "ボタン活性"
    - "権限チェック"
    - "できるかどうか"
    - "boundary"
    - "intent"

  confidence_keywords:
    high:    ["操作可否", "CanCreate", "CanUpdate", "CanDelete", "IsAllowed"]
    medium:  ["権限", "活性", "非活性", "disabled"]
    low:     ["ボタン", "表示制御"]

  anti_patterns:
    - "見た目の制御"    # CSSの話 → UI層
    - "色・フォント"    # プレゼンテーション → UI層

  typical_requests:
    - "WIP制限に基づいてカード追加可否を判定したい"
    - "承認権限がある人だけ承認ボタンを有効にしたい"
    - "状態に応じて操作ボタンを制御したい"
    - "ビジネスルールに基づいて操作可否を判定したい"

  decision_logic: |
    このパターンを選択すべき条件:
    1. 操作の実行可否がビジネスルールに依存する
    2. UIが「何ができるか」を知る必要がある
    3. 権限・状態に基づくボタン活性/非活性制御
    4. 同じ判定ロジックを複数のUIコンポーネントで使う

    このパターンを選択すべきでない条件:
    1. 見た目の制御（色・フォント・レイアウト）→ UI層
    2. 単純なnullチェック → UIで直接判定
    3. 認証（ログイン有無）→ ASP.NET Core Identity

relationship:
  works_with:
    - domain-state-machine (状態遷移の判定に使用)
    - feature-approval-workflow (承認権限の判定)

  dependencies:
    - Result<T> (Shared層のResultパターン)

design_principle: |
  UIの役割（2つに分離）:

  1. 見た目・操作（プレゼンテーション）→ UI層
     - 色、フォント、レイアウト
     - ボタンのスタイル
     - アニメーション

  2. ユーザーとの接点（何ができるか）→ Domain層（Boundary）
     - 「誰が・何に対して・何をできるか」の判定
     - ビジネスルールに基づく実行可否
     - WIP制限、承認権限、状態遷移の可否

  責務分離の例:

  | 判定内容 | 配置場所 | 理由 |
  |---------|---------|------|
  | 「重要タグは赤で表示」 | UI層（見た目） | プレゼンテーション |
  | 「WIP制限でカード追加不可」 | Domain層（Boundary） | ビジネスルール |
  | 「承認権限がない」 | Domain層（Boundary） | ビジネスルール |
  | 「下書き状態なら編集可能」 | Domain層（Boundary） | ビジネスルール |

file_structure: |
  src/Domain/{BoundedContext}/{Aggregate}/
  ├── {Aggregate}.cs                    # 集約ルート ★CanXxx()メソッドを含む
  └── Boundaries/
      ├── {Aggregate}Intent.cs          # 操作の意図（enum）
      ├── I{Aggregate}Boundary.cs       # Boundaryインターフェース
      ├── BoundaryDecision.cs           # 判定結果
      └── {Aggregate}BoundaryService.cs # Boundary実装（Entityに委譲のみ）

# ============================================================================
# 開発フロー（推奨順序）
# ============================================================================
development_flow:
  description: |
    Boundary実装の推奨フロー。この順序で実装することで、
    業務ロジックが正しくEntityに配置される。

  steps:
    - step: 1
      name: "画面設計"
      action: "Intent（ユーザーができる操作）を特定"
      output: "{Aggregate}Intent.cs"
      example: "注文画面 → 支払い、キャンセル、詳細表示"

    - step: 2
      name: "Entity設計"
      action: "各Intentに対応する CanXxx() メソッドを定義"
      output: "{Aggregate}.cs に CanPay(), CanCancel() 等を追加"
      critical: "★ 業務ルールはここに実装する"

    - step: 3
      name: "IBoundary定義"
      action: "ViewModel と Validate メソッドのシグネチャを定義"
      output: "I{Aggregate}Boundary.cs"

    - step: 4
      name: "BoundaryService実装"
      action: "Entity.CanXxx() に委譲するコードを書く"
      output: "{Aggregate}BoundaryService.cs"
      critical: "★ 業務ロジック(if文)を書かない"

  checklist:
    - "[ ] 業務ルールの if 文が BoundaryService にないか？"
    - "[ ] Entity に CanXxx() メソッドがあるか？"
    - "[ ] CanXxx() は BoundaryDecision を返すか？"
    - "[ ] BoundaryService は Entity に委譲しているか？"

# ============================================================================
# BoundaryService の責務定義（厳密）
# ============================================================================
boundary_service_responsibilities:
  do:
    - "Repository からデータを取得する"
    - "Entity のメソッドを呼び出して判定結果を得る"
    - "ViewModel を構築して返す"
    - "存在チェック（null判定）のみ許可"

  do_not:
    - "業務ルールの判定（if文で状態をチェック等）"
    - "ドメインロジックの実装"
    - "Entity の状態を直接参照して判定"

  pattern: |
    ```csharp
    // ✅ 正しいパターン: Entity に委譲
    public async Task<BoundaryDecision> ValidatePayAsync(OrderId orderId, CancellationToken ct)
    {
        var order = await _repository.GetByIdAsync(orderId, ct);
        if (order == null)
            return BoundaryDecision.Deny("注文が見つかりません");  // 存在チェックのみ許可

        return order.CanPay();  // ★ 業務ロジックは Entity に委譲
    }

    // ❌ 悪いパターン: BoundaryService に業務ロジック
    public async Task<BoundaryDecision> ValidatePayAsync(OrderId orderId, CancellationToken ct)
    {
        var order = await _repository.GetByIdAsync(orderId, ct);
        if (order.Status == OrderStatus.Paid)  // ← 業務ロジックが漏れている！
            return BoundaryDecision.Deny("既に支払い済みです");
        return BoundaryDecision.Allow();
    }
    ```

implementation:
  # ===== Entity の CanXxx() メソッド（最重要） =====
  entity_can_methods:
    file_path: "src/Domain/{BoundedContext}/{Aggregate}s/{Aggregate}.cs"
    description: |
      Entity に業務ルール判定メソッドを追加する。
      これが Boundary パターンの核心。BoundaryService はこのメソッドに委譲する。
    template: |
      namespace Domain.{BoundedContext}.{Aggregate}s;

      using Domain.{BoundedContext}.{Aggregate}s.Boundaries;

      /// <summary>
      /// {Aggregate} 集約ルート
      ///
      /// 【パターン: Boundary Pattern - Entity側】
      ///
      /// Entity は業務ルールを CanXxx() メソッドとして公開する。
      /// BoundaryService はこれらのメソッドに委譲する。
      /// </summary>
      public class {Aggregate} : AggregateRoot<{Aggregate}Id>
      {
          public {Aggregate}Status Status { get; private set; }

          // ... 他のプロパティ ...

          // ================================================================
          // 業務ルール判定メソッド（BoundaryDecision を返す）
          // ================================================================

          /// <summary>
          /// 支払い可否を判定
          /// </summary>
          public BoundaryDecision CanPay()
          {
              return Status switch
              {
                  {Aggregate}Status.Pending => BoundaryDecision.Allow(),
                  {Aggregate}Status.Paid => BoundaryDecision.Deny("既に支払い済みです"),
                  {Aggregate}Status.Cancelled => BoundaryDecision.Deny("キャンセル済みの注文は支払いできません"),
                  _ => BoundaryDecision.Deny("この状態では支払いできません")
              };
          }

          /// <summary>
          /// キャンセル可否を判定
          /// </summary>
          public BoundaryDecision CanCancel()
          {
              return Status switch
              {
                  {Aggregate}Status.Pending => BoundaryDecision.Allow(),
                  {Aggregate}Status.Paid => BoundaryDecision.Deny("支払い済みの注文はキャンセルできません"),
                  {Aggregate}Status.Cancelled => BoundaryDecision.Deny("既にキャンセル済みです"),
                  _ => BoundaryDecision.Deny("この状態ではキャンセルできません")
              };
          }

          /// <summary>
          /// 編集可否を判定
          /// </summary>
          public BoundaryDecision CanUpdate()
          {
              if (Status == {Aggregate}Status.Completed)
                  return BoundaryDecision.Deny("完了した{Aggregate}は編集できません");

              return BoundaryDecision.Allow();
          }
      }

    anti_pattern: |
      // ❌ 悪い例: BoundaryService が業務ロジックを持つ
      public class {Aggregate}BoundaryService
      {
          public BoundaryDecision ValidatePay({Aggregate} entity)
          {
              // ↓ この if 文は Entity.CanPay() に移動すべき
              if (entity.Status == {Aggregate}Status.Paid)
                  return BoundaryDecision.Deny("既に支払い済みです");
              return BoundaryDecision.Allow();
          }
      }

  # ===== Intent (操作の意図) =====
  intent:
    file_path: "src/Domain/{BoundedContext}/{Aggregate}s/Boundaries/{Aggregate}Intent.cs"
    template: |
      namespace Domain.{BoundedContext}.{Aggregate}s.Boundaries;

      /// <summary>
      /// {Aggregate}に対する操作の意図
      ///
      /// 【パターン: Boundary Pattern】
      ///
      /// 責務:
      /// - 操作の種類を列挙
      /// - Boundaryが判定対象とするアクションを定義
      ///
      /// AI実装時の注意:
      /// - 業務で必要な操作を網羅する
      /// - CRUD + ドメイン固有の操作を含める
      /// </summary>
      public enum {Aggregate}Intent
      {
          /// <summary>作成</summary>
          Create,

          /// <summary>更新</summary>
          Update,

          /// <summary>削除</summary>
          Delete,

          /// <summary>アーカイブ</summary>
          Archive,

          // ドメイン固有の操作を追加
          // 例: MoveCard, Approve, Reject, Submit
      }

  # ===== BoundaryDecision (判定結果) =====
  decision:
    file_path: "src/Domain/{BoundedContext}/{Aggregate}s/Boundaries/BoundaryDecision.cs"
    template: |
      namespace Domain.{BoundedContext}.{Aggregate}s.Boundaries;

      /// <summary>
      /// Boundary判定結果
      ///
      /// 【パターン: Boundary Pattern】
      ///
      /// 責務:
      /// - 操作可否の結果を保持
      /// - 不可の場合は理由を提供
      ///
      /// AI実装時の注意:
      /// - 不変オブジェクト（record）として実装
      /// - ファクトリメソッドで生成
      /// </summary>
      public sealed record BoundaryDecision
      {
          public bool IsAllowed { get; }
          public string? Reason { get; }

          private BoundaryDecision(bool isAllowed, string? reason = null)
          {
              IsAllowed = isAllowed;
              Reason = reason;
          }

          /// <summary>操作を許可</summary>
          public static BoundaryDecision Allow() => new(true);

          /// <summary>操作を拒否（理由付き）</summary>
          public static BoundaryDecision Deny(string reason) => new(false, reason);

          /// <summary>暗黙のbool変換</summary>
          public static implicit operator bool(BoundaryDecision decision) => decision.IsAllowed;
      }

  # ===== IBoundary (インターフェース) =====
  interface:
    file_path: "src/Domain/{BoundedContext}/{Aggregate}s/Boundaries/I{Aggregate}Boundary.cs"
    template: |
      namespace Domain.{BoundedContext}.{Aggregate}s.Boundaries;

      /// <summary>
      /// {Aggregate}のBoundaryインターフェース
      ///
      /// 【パターン: Boundary Pattern】
      ///
      /// 責務:
      /// - 「誰が・何に対して・何をできるか」の判定
      /// - ビジネスルールに基づく実行可否の判定
      ///
      /// AI実装時の注意:
      /// - メソッド名は Can{Operation} の形式
      /// - 戻り値は BoundaryDecision
      /// - ドメイン固有の判定を追加
      /// </summary>
      public interface I{Aggregate}Boundary
      {
          /// <summary>
          /// 作成可否を判定
          /// </summary>
          BoundaryDecision CanCreate({Aggregate} parent, /* 追加パラメータ */);

          /// <summary>
          /// 更新可否を判定
          /// </summary>
          BoundaryDecision CanUpdate({Aggregate} entity);

          /// <summary>
          /// 削除可否を判定
          /// </summary>
          BoundaryDecision CanDelete({Aggregate} entity);

          // ドメイン固有の判定を追加
          // 例: BoundaryDecision CanMoveCard(Board board, CardId cardId, ColumnId targetColumnId);
      }

  # ===== BoundaryService (実装) =====
  service:
    file_path: "src/Application/Infrastructure/{BoundedContext}/Boundaries/{Aggregate}BoundaryService.cs"
    description: |
      BoundaryService は「データ取得」と「Entityへの委譲」のみを行う。
      業務ロジック（if文による状態チェック等）を書いてはならない。
    template: |
      namespace Application.Infrastructure.{BoundedContext}.Boundaries;

      using Domain.{BoundedContext}.{Aggregate}s;
      using Domain.{BoundedContext}.{Aggregate}s.Boundaries;

      /// <summary>
      /// {Aggregate}のBoundary実装
      ///
      /// 【パターン: Boundary Pattern - BoundaryService側】
      ///
      /// ★★★ 重要: このクラスに業務ロジックを書いてはならない ★★★
      ///
      /// やること:
      /// - Repository からデータを取得する
      /// - Entity のメソッドを呼び出して判定結果を得る
      /// - ViewModel を構築して返す
      ///
      /// やらないこと:
      /// - 業務ルールの判定（if文で状態をチェック等）
      /// - ドメインロジックの実装
      /// </summary>
      public class {Aggregate}BoundaryService : I{Aggregate}Boundary
      {
          private readonly I{Aggregate}Repository _repository;

          public {Aggregate}BoundaryService(I{Aggregate}Repository repository)
          {
              _repository = repository;
          }

          /// <summary>
          /// 支払い可否を検証
          /// </summary>
          public async Task<BoundaryDecision> ValidatePayAsync(
              {Aggregate}Id id,
              CancellationToken ct = default)
          {
              var entity = await _repository.GetByIdAsync(id, ct);
              if (entity == null)
                  return BoundaryDecision.Deny("{Aggregate}が見つかりません");  // 存在チェックのみ許可

              // ★ 業務ロジックは Entity に委譲
              return entity.CanPay();
          }

          /// <summary>
          /// キャンセル可否を検証
          /// </summary>
          public async Task<BoundaryDecision> ValidateCancelAsync(
              {Aggregate}Id id,
              CancellationToken ct = default)
          {
              var entity = await _repository.GetByIdAsync(id, ct);
              if (entity == null)
                  return BoundaryDecision.Deny("{Aggregate}が見つかりません");

              // ★ 業務ロジックは Entity に委譲
              return entity.CanCancel();
          }

          /// <summary>
          /// 更新可否を検証
          /// </summary>
          public async Task<BoundaryDecision> ValidateUpdateAsync(
              {Aggregate}Id id,
              CancellationToken ct = default)
          {
              var entity = await _repository.GetByIdAsync(id, ct);
              if (entity == null)
                  return BoundaryDecision.Deny("{Aggregate}が見つかりません");

              // ★ 業務ロジックは Entity に委譲
              return entity.CanUpdate();
          }
      }

    anti_pattern: |
      // ❌ 絶対にやってはいけないパターン
      public class {Aggregate}BoundaryService
      {
          public async Task<BoundaryDecision> ValidatePayAsync({Aggregate}Id id, CancellationToken ct)
          {
              var entity = await _repository.GetByIdAsync(id, ct);

              // ↓ これは業務ロジック！Entity.CanPay() に移動すべき
              if (entity.Status == {Aggregate}Status.Paid)
                  return BoundaryDecision.Deny("既に支払い済みです");

              // ↓ これも業務ロジック！
              if (entity.TotalAmount <= 0)
                  return BoundaryDecision.Deny("金額が不正です");

              return BoundaryDecision.Allow();
          }
      }

  # ===== Usage in Handler =====
  usage_handler:
    file_path: "src/Application/Features/{Feature}/{Feature}CommandHandler.cs"
    template: |
      using Domain.{BoundedContext}.{Aggregate}s.Boundaries;

      /// <summary>
      /// Boundary使用例（Handler内）
      ///
      /// 【パターン: Boundary Pattern】
      /// </summary>
      public class {Feature}CommandHandler : ICommandHandler<{Feature}Command, Result<Guid>>
      {
          private readonly I{Aggregate}Boundary _{aggregate}Boundary;
          private readonly I{Aggregate}Repository _repository;

          public {Feature}CommandHandler(
              I{Aggregate}Boundary {aggregate}Boundary,
              I{Aggregate}Repository repository)
          {
              _{aggregate}Boundary = {aggregate}Boundary;
              _repository = repository;
          }

          public async Task<Result<Guid>> Handle({Feature}Command request, CancellationToken ct)
          {
              var parent = await _repository.GetByIdAsync(request.ParentId, ct);
              if (parent is null)
                  return Result.Fail<Guid>("対象が見つかりません");

              // Boundary経由で操作可否を判定
              var decision = _{aggregate}Boundary.CanCreate(parent);
              if (!decision.IsAllowed)
                  return Result.Fail<Guid>(decision.Reason!);

              // ビジネスロジックの実行
              // ...

              return Result.Success(newEntityId);
          }
      }

  # ===== Usage in UI =====
  usage_ui:
    file_path: "src/Application/Features/{Feature}/{Feature}Page.razor"
    template: |
      @*
      Boundary使用例（UI）

      【パターン: Boundary Pattern】

      UIはBoundaryの判定結果を表示するだけ。
      判定ロジックはUIに書かない。
      *@

      @inject I{Aggregate}Boundary {Aggregate}Boundary

      <button disabled="@(!_canCreate.IsAllowed)"
              title="@_canCreate.Reason">
          追加
      </button>

      @code {
          private BoundaryDecision _canCreate = BoundaryDecision.Deny("読み込み中");

          protected override void OnParametersSet()
          {
              // Boundary経由で判定（UIにロジックを書かない）
              _canCreate = {Aggregate}Boundary.CanCreate(_parent);
          }
      }

ai_guidance:
  when_to_use:
    - "操作の実行可否がビジネスルールに依存する場合"
    - "UIが「何ができるか」を知る必要がある場合"
    - "権限・状態に基づくボタン活性/非活性制御"
    - "同じ判定ロジックを複数のUIコンポーネントで使う場合"

  when_not_to_use:
    - "見た目の制御のみ（色・フォント・レイアウト）→ UI層で完結"
    - "単純なnullチェック → UIで直接判定"
    - "認証（ログイン有無）→ ASP.NET Core Identity"

  implementation_steps:
    - step: 1
      description: "Domain層にBoundariesフォルダを作成"
      files: ["src/Domain/{BoundedContext}/{Aggregate}s/Boundaries/"]
    - step: 2
      description: "{Aggregate}Intentを定義（必要な操作を列挙）"
      files: ["{Aggregate}Intent.cs"]
    - step: 3
      description: "BoundaryDecisionを実装（判定結果）"
      files: ["BoundaryDecision.cs"]
    - step: 4
      description: "I{Aggregate}Boundaryインターフェースを定義"
      files: ["I{Aggregate}Boundary.cs"]
    - step: 5
      description: "{Aggregate}BoundaryServiceを実装"
      files: ["{Aggregate}BoundaryService.cs"]
    - step: 6
      description: "DIに登録（Scoped）"
      files: ["Program.cs"]
    - step: 7
      description: "Handler/UIでBoundaryを使用"
      files: ["{Feature}CommandHandler.cs", "{Feature}Page.razor"]

  common_mistakes:
    - mistake: "BoundaryServiceに業務ロジック（if文）を書く"
      severity: "critical"
      symptom: "BoundaryService内でentity.Statusをチェックするif文がある"
      solution: "Entity.CanXxx()メソッドを作成し、BoundaryServiceはそれに委譲する。"
      example: |
        ❌ 悪い例:
        if (entity.Status == OrderStatus.Paid)
            return BoundaryDecision.Deny("支払い済み");

        ✅ 良い例:
        return entity.CanPay();

    - mistake: "Entityに CanXxx() メソッドがない"
      severity: "critical"
      symptom: "Entityがデータの入れ物になっている（Anemic Domain Model）"
      solution: "Entityに業務ルールを判定するCanXxx()メソッドを追加する。"

    - mistake: "UIにビジネスロジックを書く"
      severity: "high"
      solution: "判定ロジックはEntity.CanXxx()に集約。UIはBoundaryの結果を表示するだけ。"

    - mistake: "BoundaryでDbContextを使う"
      severity: "high"
      solution: "Boundaryはドメイン層。DBアクセスはRepository経由。BoundaryServiceはApplication層。"

    - mistake: "BoundaryDecisionの理由を省略"
      severity: "medium"
      solution: "Deny時は必ず理由を付ける。UIでツールチップ表示やエラーメッセージに使う。"

    - mistake: "Boundaryを直接newする"
      severity: "medium"
      solution: "DIでI{Aggregate}Boundaryを注入。テスト時にモック可能。"

    - mistake: "複数のBoundaryで判定ロジックが重複"
      severity: "medium"
      solution: "共通の判定はEntity.CanXxx()に実装。複数集約にまたがる場合はDomainServiceに委譲。"

  key_patterns:
    - pattern: "BoundaryDecision"
      description: "操作可否の判定結果。IsAllowedとReasonを持つ。"
    - pattern: "Can{Operation}"
      description: "操作可否を判定するメソッド。BoundaryDecisionを返す。"
    - pattern: "Intent enum"
      description: "操作の種類を列挙。Boundaryが判定対象とするアクション。"

  design_decision:
    boundary_vs_authorization: |
      BoundaryとAuthorizationの違い:

      | 項目 | Boundary | Authorization |
      |-----|----------|---------------|
      | 判定対象 | ビジネスルール | ロール・権限 |
      | 配置場所 | Domain層 | Pipeline Behavior |
      | 例 | WIP制限、状態遷移 | Admin権限、Read権限 |
      | 実行タイミング | Handler内/UI | Pipeline（自動） |

      両方必要な場合:
      1. AuthorizationBehavior: 「この操作を実行する権限があるか」
      2. Boundary: 「この操作がビジネスルール上可能か」

    testing_strategy: |
      テスト戦略:

      1. BoundaryServiceの単体テスト:
         - 各判定条件が正しく動作すること
         - Deny時に適切な理由が返されること

      2. Handlerの統合テスト:
         - Boundary拒否時にResult.Failが返されること
         - Boundary許可時に処理が続行すること

      3. UIのテスト:
         - Boundary結果に応じてボタンが有効/無効になること

wiring:
  service_registrations:
    - "services.AddScoped<I{Aggregate}Boundary, {Aggregate}BoundaryService>();"

  dependencies:
    nuget: []
    patterns:
      - "domain-state-machine (状態遷移判定に使用する場合)"

evidence:
  # 実際の実装例があれば追加
  domain_layer:
    boundary_service: "未実装 - カンバンシステムでの実装を推奨"
  notes: |
    このパターンはカンバンシステム実装時のフィードバックから生まれました。
    WIP制限やカード移動可否の判定をドメイン層に集約することで、
    UIとビジネスロジックの責務を明確に分離できます。

changelog:
  - version: 2.0.0
    date: 2025-11-26
    changes:
      - "【Breaking】業務ロジックの配置を明確化: Entity.CanXxx() に集約"
      - "Robustness Analysis との対応表を追加"
      - "開発フロー（推奨順序）とチェックリストを追加"
      - "BoundaryService の責務定義を厳密化（委譲のみ）"
      - "Entity の CanXxx() メソッドテンプレートを追加"
      - "common_mistakes に severity を追加"
      - "アンチパターンの例を強化"

  - version: 1.0.0
    date: 2025-11-23
    changes:
      - "初版リリース"
      - "カンバンシステム実装のフィードバックからパターン化"
      - "Intent-Boundary分離の設計思想を文書化"
