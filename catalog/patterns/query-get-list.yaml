id: query-get-list
version: 1.0.0
name: GetListQuery Pattern
category: query-pattern
intent: 全件取得クエリのテンプレート（キャッシュ対応）
description: |
  エンティティの全件を取得するシンプルなクエリパターン。
  キャッシュを有効化して、頻繁にアクセスされるデータの取得を高速化できます。

applicability:
  required_characteristics:
    - op:read-only
  recommended_for:
    - layer:application
  conflicts_with:
    - op:mutates-state

dependencies:
  patterns:
    - caching-behavior
  nuget:
    - name: "MediatR"
      version: "^12.0.0"
      required: true
      note: "IRequest<T>とIRequestHandler<,>を提供"
    - name: "Dapper"
      version: "^2.1.0"
      required: true
      note: "Read Modelの高速クエリ用"

wiring:
  service_registrations:
    - registration: "services.AddScoped<I{Entity}ReadRepository, Dapper{Entity}ReadRepository>()"
      lifetime: "Scoped"
      note: "ReadRepositoryはScopedで登録"

  blazor_wasm_notes:
    - "Blazor WebAssemblyではScopedとSingletonは同じ動作だが、Scopedで統一すること"
    - "MediatRに依存するサービスは必ずScopedで登録"

  lifetime_rules:
    - rule: "QueryHandler、ReadRepositoryはすべてScopedで登録"
      reason: "MediatRがScopedなので、依存するサービスもScopedにしないとDIエラー"

implementation:
  file_path: "src/Application/Features/Get{Entity}s/Get{Entity}sQuery.cs"
  template: |
    using {BoundedContext}.Shared.Application;
    using {BoundedContext}.Shared.Application.DTOs;
    using Shared.Application;
    using Shared.Application.Interfaces;

    namespace Application.Features.Get{Entity}s;

    /// <summary>
    /// {Entity}一覧取得Query
    /// </summary>
    public class Get{Entity}sQuery : IQuery<Result<IEnumerable<{Entity}Dto>>>, ICacheableQuery
    {
        /// <summary>
        /// キャッシュキー（全{Entity}一覧は固定キー）
        /// </summary>
        public string GetCacheKey() => "{entity}s-all";

        /// <summary>
        /// キャッシュ期間: 5分
        /// </summary>
        public int CacheDurationMinutes => 5;
    }

    // Handler 実装
    /// <summary>
    /// {Entity}一覧取得クエリハンドラー (工業製品化版)
    ///
    /// 【処理フロー】
    /// 1. I{Entity}ReadRepository経由でデータ取得（Dapper）
    /// 2. DTOのリストを返す
    ///
    /// 【実装ガイド】
    /// - Read Model（Dapper）を使用して最適化
    /// - Repository（EF Core）ではなくReadRepository（Dapper）を使用
    /// - キャッシュはCachingBehaviorが自動的に処理
    /// - 参照系なので書き込み処理は行わない
    /// </summary>
    public class Get{Entity}sQueryHandler
        : QueryPipeline<Get{Entity}sQuery, IEnumerable<{Entity}Dto>>
    {
        private readonly I{Entity}ReadRepository _readRepository;

        public Get{Entity}sQueryHandler(I{Entity}ReadRepository readRepository)
        {
            _readRepository = readRepository;
        }

        protected override async Task<Result<IEnumerable<{Entity}Dto>>> ExecuteAsync(
            Get{Entity}sQuery query,
            CancellationToken ct)
        {
            // I{Entity}ReadRepository経由で取得（Dapper使用）
            // - SELECT * FROM {Entity}s WHERE IsDeleted = 0
            // - シンプルなクエリで高速
            var items = await _readRepository.GetAllAsync(ct);

            return Result.Success(items);
        }
    }

example_usage: |
  // ProductCatalog の場合
  public sealed record GetProductsQuery()
      : IQuery<Result<IEnumerable<ProductDto>>>, ICacheableQuery
  {
      public string GetCacheKey() => "products-all";
      public int CacheDurationMinutes => 5;
  }

  // UI から使用
  public sealed class ProductListStore
  {
      public async Task LoadAsync(CancellationToken ct)
      {
          var query = new GetProductsQuery();
          var result = await _mediator.Send(query, ct);

          if (result.IsSuccess)
          {
              _state = _state with { Products = result.Value.ToList() };
              await NotifyStateChangedAsync();
          }
      }
  }

file_structure: |
  src/Application/Features/Get{Entity}s/
  ├── Get{Entity}sQuery.cs           # Query定義 + Handler実装

  src/Application/Infrastructure/{BoundedContext}/Application/DTOs/
  └── {Entity}Dto.cs                 # DTO定義

  src/Application/Core/Queries/
  └── QueryPipeline.cs               # Base class for query handlers

tests:
  - name: "全件取得が成功する"
    given: "データベースに複数の {Entity} が存在"
    when: "Get{Entity}sQuery を実行"
    then: "すべてのアクティブな {Entity} が返される"
    expect: "全件取得成功"

  - name: "削除済みは含まれない"
    given: "削除済みの {Entity} が存在"
    when: "Get{Entity}sQuery を実行"
    then: "IsDeleted = 0 のデータのみ返される"
    expect: "論理削除済みを除外"

  - name: "キャッシュが有効になる"
    given: "CachingBehavior が有効"
    when: "同じクエリを2回実行"
    then: "2回目はキャッシュから返される"
    expect: "キャッシュヒット"

ai_guidance:
  when_to_use:
    - "マスタデータの一覧表示"
    - "ドロップダウンリストのデータソース"
    - "データ件数が1000件未満の場合"

  when_not_to_use:
    - "大量データ（1000件以上）→ SearchQuery + Paging を使用"
    - "リアルタイム性が必要な場合 → キャッシュを無効化"
    - "条件検索が必要な場合 → SearchQuery を使用"

  common_mistakes:
    - mistake: "独自のCQRS/Mediator実装を作成"
      description: "このプロジェクトはMediatRを使用しており、独自のQuery/Handler基盤は不要"
      solution: "MediatRのIRequest<T>とIRequestHandler<TRequest, TResponse>を使用"
      severity: "critical"

    - mistake: "ICacheableQuery を実装し忘れる"
      solution: "頻繁にアクセスされるクエリには必ずキャッシュを実装"
      severity: "medium"

    - mistake: "大量データを全件取得しようとする"
      solution: "1000件以上の場合は SearchQuery + Paging パターンを使用"
      severity: "high"

    - mistake: "削除済みデータをフィルタしない"
      solution: "WHERE IsDeleted = 0 を必ず追加"
      severity: "high"

    - mistake: "Singleton/Scoped混在によるDIエラー"
      description: "MediatR(Scoped)に依存するサービスをSingletonで登録するとDIエラー"
      solution: "QueryHandler、ReadRepositoryはすべてScopedで登録"
      severity: "high"
      error_message: "Cannot consume scoped service from singleton"

    - mistake: "HandleAsyncメソッド名を使用"
      description: "MediatRのIRequestHandlerはHandleメソッド（Asyncなし）"
      solution: "Task<T> Handle(TRequest request, CancellationToken cancellationToken) を使用"
      severity: "medium"

    - mistake: "QueryでEF Coreを使用"
      description: "このプロジェクトはCQRSを採用しており、QueryはDapper（Read Model）を使用"
      solution: "ReadRepositoryをDapperで実装し、EF Coreは書き込み側でのみ使用"
      severity: "medium"

    - mistake: "MediatRパッケージをインストールせずにQuery作成"
      description: "IRequest<T>、IRequestHandler<,>はMediatRパッケージに含まれる"
      solution: "dotnet add package MediatR"
      severity: "critical"

performance:
  without_cache: "50-100ms (データベースクエリ)"
  with_cache: "< 1ms (メモリから取得)"
  recommended_cache_duration: "5分"

changelog:
  - version: 1.0.0
    date: 2025-11-05
    changes:
      - "初版リリース"

evidence:
  query: "src/Application/Features/GetProducts/GetProductsQuery.cs"
  handler: "src/Application/Features/GetProducts/GetProductsQueryHandler.cs"
  dto: "src/Application/Infrastructure/ProductCatalog/Application/DTOs/ProductDto.cs"
  read_repository_interface: "src/Application/Infrastructure/ProductCatalog/Application/IProductReadRepository.cs"
  read_repository_implementation: "src/Application/Infrastructure/ProductCatalog/Infrastructure/Persistence/Repositories/DapperProductReadRepository.cs"
