# 1. イントロダクション

[← 目次に戻る](00_README.md)

---

## 1. イントロダクション

### 1.1 このアーキテクチャが解決する課題

Blazor アプリケーション開発における典型的な課題:

#### ❌ よくある問題

```csharp
// アンチパターン:すべてをComponentに詰め込む
@code {
    private List<Product> products = new();
    
    protected override async Task OnInitializedAsync()
    {
        // ❌ Componentが直接DBアクセス
        products = await DbContext.Products.ToListAsync();
    }
    
    private async Task DeleteProduct(Guid id)
    {
        // ❌ ビジネスロジックがUI層に散在
        var product = products.First(p => p.Id == id);
        if (product.Stock > 0)
        {
            // ❌ エラーハンドリングが不統一
            await JsRuntime.InvokeVoidAsync("alert", "在庫があるため削除できません");
            return;
        }
        
        // ❌ DbContextの寿命管理が不適切(Blazor Serverで長期保持)
        DbContext.Products.Remove(product);
        await DbContext.SaveChangesAsync();
        
        // ❌ 他のユーザーへの通知なし
        products.Remove(product);
    }
}
```

**問題点:**
- UI層にビジネスロジックが散在
- DbContextの長期保持によるメモリリーク
- テストが困難
- 責務が不明確
- 並行制御なし
- リアルタイム更新なし

#### ✅ このアーキテクチャの解決策

```csharp
// Smart Component: 手順の呼び出しのみ
@inject ProductsStore Store
@inject ProductListActions Actions

@if (State.IsLoading) { <LoadingIndicator /> }
else 
{
    foreach (var product in State.Products)
    {
        <ProductCard Product="product" OnDelete="Actions.DeleteAsync" />
    }
}

@code {
    private ProductsState State => Store.GetState();
    
    protected override async Task OnInitializedAsync()
    {
        Store.OnChangeAsync += () => InvokeAsync(StateHasChanged);
        await Actions.LoadAsync();  // ✅ UI手順の呼び出しのみ
    }
}

// PageActions: UI手順のオーケストレーション
public class ProductListActions
{
    private readonly ProductsStore _store;
    private readonly IConfirmDialog _confirm;
    private readonly IToast _toast;
    
    public async Task DeleteAsync(Guid id, CancellationToken ct = default)
    {
        if (!await _confirm.ShowAsync("削除しますか?")) return;
        
        var result = await _store.DeleteAsync(id, ct);  // ✅ I/O処理はStoreに完全委譲
        
        if (result) _toast.Success("削除しました");
        else _toast.Error("削除に失敗しました");
    }
}

// Store: I/O実行と状態管理
public class ProductsStore
{
    private readonly IServiceScopeFactory _scopeFactory;
    
    public async Task<bool> DeleteAsync(Guid id, CancellationToken ct = default)
    {
        using var scope = _scopeFactory.CreateScope();  // ✅ 都度スコープ
        var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
        
        var result = await mediator.Send(new DeleteProductCommand(id), ct);  // ✅ CQRS
        // ✅ パイプライン: Validation → Authorization → Transaction
        
        if (result.IsSuccess)
            await LoadAsync(ct);  // ✅ 最新状態を再取得
        
        return result.IsSuccess;
    }
}

// Handler: ビジネスロジック
public class DeleteProductHandler : IRequestHandler<DeleteProductCommand, Result>
{
    private readonly IProductRepository _repo;
    
    public async Task<Result> Handle(DeleteProductCommand cmd, CancellationToken ct)
    {
        var product = await _repo.GetAsync(new ProductId(cmd.Id), ct);
        if (product is null) return Result.Fail("商品が見つかりません");
        
        product.Delete();  // ✅ ドメインルール適用
        await _repo.SaveAsync(product, ct);
        
        return Result.Success();
    }
}
```

### 1.2 このアーキテクチャの特徴

| 特徴 | 説明 | 効果 |
|------|------|------|
| **PageActions パターン** | UI手順とI/Oの分離 | テスタビリティ向上 |
| **Smart/Dumb 分離** | 状態管理と表示の分離 | 再利用性向上 |
| **Store パターン** | 不変状態管理 | 予測可能なUI |
| **CQRS** | Command/Query分離 | パフォーマンス最適化 |
| **Vertical Slice** | 機能単位の凝集 | 変更容易性 |
| **MediatR Pipeline** | 横断的関心事の統一 | 一貫した制御 |
| **Idempotency** | 重複実行の防止 | 信頼性向上 |
| **SAGA** | 分散トランザクション | 整合性保証 |
| **SignalR/Outbox** | リアルタイム更新 | UX向上 |

### 1.3 適用推奨シナリオ

#### ✅ 最適なケース

- **中〜大規模業務アプリケーション** (10+ 画面)
- **チーム開発** (5-20名)
- **長期保守が必要** (3年以上)
- **複雑な業務ロジック** (権限管理、承認フロー等)
- **リアルタイム更新** (在庫管理、チャット等)

#### ⚠️ オーバーエンジニアリングの可能性

- **小規模プロトタイプ** (< 5画面)
- **単一開発者**
- **読み取り専用ダッシュボード**
- **短期プロジェクト** (< 6ヶ月)

---
