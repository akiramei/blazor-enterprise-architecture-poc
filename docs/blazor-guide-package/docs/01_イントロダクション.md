# 1. イントロダクション

[← 目次に戻る](00_README.md)

---

## 1. イントロダクション

### 1.1 このアーキテクチャが解決する課題

Blazor アプリケーション開発における典型的な課題:

#### ❌ よくある問題

```csharp
// アンチパターン:すべてをComponentに詰め込む
@code {
    private List<Product> products = new();
    
    protected override async Task OnInitializedAsync()
    {
        // ❌ Componentが直接DBアクセス
        products = await DbContext.Products.ToListAsync();
    }
    
    private async Task DeleteProduct(Guid id)
    {
        // ❌ ビジネスロジックがUI層に散在
        var product = products.First(p => p.Id == id);
        if (product.Stock > 0)
        {
            // ❌ エラーハンドリングが不統一
            await JsRuntime.InvokeVoidAsync("alert", "在庫があるため削除できません");
            return;
        }
        
        // ❌ DbContextの寿命管理が不適切(Blazor Serverで長期保持)
        DbContext.Products.Remove(product);
        await DbContext.SaveChangesAsync();
        
        // ❌ 他のユーザーへの通知なし
        products.Remove(product);
    }
}
```

**問題点:**
- UI層にビジネスロジックが散在
- DbContextの長期保持によるメモリリーク
- テストが困難
- 責務が不明確
- 並行制御なし
- リアルタイム更新なし

#### ✅ このアーキテクチャの解決策

```csharp
// Smart Component: 手順の呼び出しのみ
@inject ProductsStore Store
@inject ProductListActions Actions

@if (State.IsLoading) { <LoadingIndicator /> }
else 
{
    foreach (var product in State.Products)
    {
        <ProductCard Product="product" OnDelete="Actions.DeleteAsync" />
    }
}

@code {
    private ProductsState State => Store.GetState();
    
    protected override async Task OnInitializedAsync()
    {
        Store.OnChangeAsync += () => InvokeAsync(StateHasChanged);
        await Actions.LoadAsync();  // ✅ UI手順の呼び出しのみ
    }
}

// PageActions: UI手順のオーケストレーション
public class ProductListActions
{
    private readonly ProductsStore _store;
    private readonly IConfirmDialog _confirm;
    private readonly IToast _toast;
    
    public async Task DeleteAsync(Guid id, CancellationToken ct = default)
    {
        if (!await _confirm.ShowAsync("削除しますか?")) return;
        
        var result = await _store.DeleteAsync(id, ct);  // ✅ I/O処理はStoreに完全委譲
        
        if (result) _toast.Success("削除しました");
        else _toast.Error("削除に失敗しました");
    }
}

// Store: I/O実行と状態管理
public class ProductsStore
{
    private readonly IServiceScopeFactory _scopeFactory;
    
    public async Task<bool> DeleteAsync(Guid id, CancellationToken ct = default)
    {
        using var scope = _scopeFactory.CreateScope();  // ✅ 都度スコープ
        var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
        
        var result = await mediator.Send(new DeleteProductCommand(id), ct);  // ✅ CQRS
        // ✅ パイプライン: Validation → Authorization → Transaction
        
        if (result.IsSuccess)
            await LoadAsync(ct);  // ✅ 最新状態を再取得
        
        return result.IsSuccess;
    }
}

// Handler: ビジネスロジック
public class DeleteProductHandler : IRequestHandler<DeleteProductCommand, Result>
{
    private readonly IProductRepository _repo;
    
    public async Task<Result> Handle(DeleteProductCommand cmd, CancellationToken ct)
    {
        var product = await _repo.GetAsync(new ProductId(cmd.Id), ct);
        if (product is null) return Result.Fail("商品が見つかりません");
        
        product.Delete();  // ✅ ドメインルール適用
        await _repo.SaveAsync(product, ct);
        
        return Result.Success();
    }
}
```

### 1.2 このアーキテクチャの特徴

| 特徴 | 説明 | 効果 |
|------|------|------|
| **PageActions パターン** | UI手順とI/Oの分離 | テスタビリティ向上 |
| **Smart/Dumb 分離** | 状態管理と表示の分離 | 再利用性向上 |
| **Store パターン** | 不変状態管理 | 予測可能なUI |
| **CQRS** | Command/Query分離 | パフォーマンス最適化 |
| **Vertical Slice** | 機能単位の凝集 | 変更容易性 |
| **MediatR Pipeline** | 横断的関心事の統一 | 一貫した制御 |
| **Idempotency** | 重複実行の防止 | 信頼性向上 |
| **SAGA** | 分散トランザクション | 整合性保証 |
| **SignalR/Outbox** | リアルタイム更新 | UX向上 |

### 1.3 適用推奨シナリオ

#### ✅ 最適なケース

- **中〜大規模業務アプリケーション** (10+ 画面)
- **チーム開発** (5-20名)
- **長期保守が必要** (3年以上)
- **複雑な業務ロジック** (権限管理、承認フロー等)
- **リアルタイム更新** (在庫管理、チャット等)

#### ⚠️ オーバーエンジニアリングの可能性

- **小規模プロトタイプ** (< 5画面)
- **単一開発者**
- **読み取り専用ダッシュボード**
- **短期プロジェクト** (< 6ヶ月)

---

### 1.4 段階的な学習パス

#### **3層アーキテクチャ経験者向け（推奨）**

WPF/WinForms + RESTful Web API の経験がある方は、以下の順序で学習することを推奨します。

**Step 1: 既知の概念から始める（30分）**
1. [16_3層アーキテクチャからの移行ガイド](16_3層アーキテクチャからの移行ガイド.md) を読む
2. [05_レイヤー構成と責務](05_レイヤー構成と責務.md) で3層アーキテクチャとの対応を確認

**Step 2: UI層の新パターンを理解（1時間）**
1. Dumb Component → WPFのUserControlと同じ
2. Smart Component → WPFのWindowと同じ
3. Store → ViewModelの状態管理部分
4. PageActions → ViewModelのICommand部分

**Step 3: MediatRとCQRSを理解（1時間）**
1. なぜMediatRが必要か → Pipeline Behaviorsのメリット
2. CQRSとは何か → 読み取りと書き込みの最適化

**Step 4: 実装パターンを確認（30分）**
1. [06_具体例_商品管理機能](06_具体例_商品管理機能.md) でCRUD全パターンを確認
2. [03_パターンカタログ一覧](03_パターンカタログ一覧.md) を実装時のリファレンスに

**合計学習時間: 約3時間**

---

#### **Blazor初心者向け**

Blazor未経験の方は、以下の順序で学習することを推奨します。

**Step 1: 全体像の把握（30分）**
1. [02_アーキテクチャ概要](02_アーキテクチャ概要.md) で設計原則を理解
2. [04_全体アーキテクチャ図](04_全体アーキテクチャ図.md) でデータフローを確認

**Step 2: 各層の詳細を順番に学習（3時間）**
1. [07_UI層の詳細設計](07_UI層の詳細設計.md) - Component, Store, Actions
2. [08_Application層の詳細設計](08_Application層の詳細設計.md) - Command, Query, Handler
3. [09_Domain層の詳細設計](09_Domain層の詳細設計.md) - Entity, Value Object
4. [10_Infrastructure層の詳細設計](10_Infrastructure層の詳細設計.md) - Repository

**Step 3: 実装パターンを確認（1時間）**
1. [06_具体例_商品管理機能](06_具体例_商品管理機能.md)
2. [03_パターンカタログ一覧](03_パターンカタログ一覧.md)

**合計学習時間: 約4.5時間**

---

#### **実装を始める方**

すぐに実装を始めたい方は、以下をクイックリファレンスとして活用してください。

**実装時のチェックリスト:**
1. [03_パターンカタログ一覧](03_パターンカタログ一覧.md) - パターン選択フローチャート
2. [06_具体例_商品管理機能](06_具体例_商品管理機能.md) - コード例のテンプレート
3. [14_ベストプラクティス](14_ベストプラクティス.md) - よくある落とし穴
4. [13_テスト戦略](13_テスト戦略.md) - テストの書き方

---
