# 7. UI層の詳細設計

[← 目次に戻る](00_README.md)

---

## 7. UI層の詳細設計

### 7.1 Dumb Component(純粋表示コンポーネント)

#### **設計原則**

- **Pure Presentation**: 表示のみを担当
- **No State**: 内部状態を持たない
- **Parameters + EventCallback**: 外部からデータを受け取り、イベントを発火

#### **実装例**

```csharp
@* ProductCard.razor *@
<div class="product-card">
    <div class="product-header">
        <h3>@Product.Name</h3>
        <span class="product-price">@Product.DisplayPrice</span>
    </div>
    
    <div class="product-body">
        <p>@Product.Description</p>
        <span class="product-stock">在庫: @Product.Stock</span>
    </div>
    
    <div class="product-actions">
        <button class="btn btn-primary" @onclick="HandleEdit">編集</button>
        <button class="btn btn-danger" @onclick="HandleDelete">削除</button>
    </div>
</div>

@code {
    /// <summary>
    /// 表示する商品データ
    /// </summary>
    [Parameter, EditorRequired]
    public ProductDto Product { get; set; } = default!;
    
    /// <summary>
    /// 編集ボタンクリック時のコールバック
    /// </summary>
    [Parameter]
    public EventCallback<Guid> OnEdit { get; set; }
    
    /// <summary>
    /// 削除ボタンクリック時のコールバック
    /// </summary>
    [Parameter]
    public EventCallback<Guid> OnDelete { get; set; }
    
    private Task HandleEdit() => OnEdit.InvokeAsync(Product.Id);
    private Task HandleDelete() => OnDelete.InvokeAsync(Product.Id);
}
```

#### **注意点**

```csharp
// ❌ Dumbコンポーネントで禁止されている操作

// 1. 内部状態の保持
private bool _isExpanded = false;  // NG

// 2. I/O操作
private async Task LoadDetails()
{
    await HttpClient.GetAsync(...);  // NG
}

// 3. ビジネスロジック
private bool CanDelete()
{
    return Product.Stock == 0;  // NG(親に委譲)
}

// 4. 直接のナビゲーション
private void NavigateToEdit()
{
    NavigationManager.NavigateTo(...);  // NG
}

// ✅ すべての操作はEventCallbackで親コンポーネントに委譲
[Parameter] public EventCallback<Guid> OnDelete { get; set; }
```

### 7.2 Smart Component(ページコンポーネント)

#### **設計原則**

- **Orchestration Only**: 手順の呼び出しのみ
- **State Subscription**: Storeの状態を購読
- **No I/O**: I/OはPageActionsに委譲

#### **実装例**

```csharp
@* ProductList.razor *@
@page "/products"
@inject ProductsStore Store
@inject ProductListActions Actions
@implements IDisposable

<PageTitle>商品一覧</PageTitle>

<div class="page-header">
    <h1>商品管理</h1>
    <button class="btn btn-success" @onclick="Actions.CreateAsync">新規作成</button>
</div>

@if (State.IsLoading)
{
    <LoadingIndicator Message="読み込み中..." />
}
else if (!string.IsNullOrEmpty(State.ErrorMessage))
{
    <ErrorAlert Message="@State.ErrorMessage" OnRetry="Actions.LoadAsync" />
}
else if (!State.Products.Any())
{
    <EmptyState Message="商品がありません" />
}
else
{
    <div class="product-grid">
        @foreach (var product in State.Products)
        {
            <ProductCard 
                Product="@product" 
                OnEdit="Actions.EditAsync"
                OnDelete="Actions.DeleteAsync" />
        }
    </div>
    
    @if (State.TotalCount > State.Products.Count)
    {
        <Pagination 
            CurrentPage="@State.CurrentPage"
            TotalPages="@State.TotalPages"
            OnPageChanged="Actions.LoadPageAsync" />
    }
}

@code {
    /// <summary>
    /// Storeから現在の状態を取得
    /// </summary>
    private ProductsState State => Store.GetState();
    
    protected override async Task OnInitializedAsync()
    {
        // 1. Storeの変更を購読
        Store.OnChangeAsync += HandleStateChanged;
        
        // 2. 初期データをロード(Actionsに委譲)
        await Actions.LoadAsync();
    }
    
    /// <summary>
    /// State変更時のハンドラー
    /// Blazor Serverの描画スレッドへマーシャリング
    /// </summary>
    private Task HandleStateChanged()
    {
        return InvokeAsync(StateHasChanged);
    }
    
    /// <summary>
    /// Dispose時にイベント購読を解除
    /// </summary>
    public void Dispose()
    {
        Store.OnChangeAsync -= HandleStateChanged;
    }
}
```

#### **ライフサイクルでの注意点**

```csharp
// ✅ 正しいライフサイクル管理

protected override async Task OnInitializedAsync()
{
    // 1. 最初にイベント購読(データロード前)
    Store.OnChangeAsync += HandleStateChanged;
    
    // 2. その後にデータロード
    await Actions.LoadAsync();
}

// ✅ 必ずDispose
public void Dispose()
{
    Store.OnChangeAsync -= HandleStateChanged;
}

// ❌ よくある間違い

// 間違い1: OnAfterRenderAsyncで購読
protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender)
    {
        Store.OnChangeAsync += HandleStateChanged;  // NG: 初回レンダリング後では遅い
    }
}

// 間違い2: Disposeしない
// メモリリークの原因!
```

### 7.3 PageActions(UI手順オーケストレーション)

#### **設計原則**

- **UI Flow Only**: UI手順のみを担当
- **No I/O**: I/OはStoreに完全委譲
- **User Interaction**: ダイアログ、トースト、ナビゲーション

#### **実装例**

```csharp
/// <summary>
/// 商品一覧画面のUI手順を管理
/// </summary>
public sealed class ProductListActions
{
    private readonly ProductsStore _store;
    private readonly IConfirmDialog _confirm;
    private readonly IToast _toast;
    private readonly NavigationManager _navigation;
    private readonly ILogger<ProductListActions> _logger;
    
    public ProductListActions(
        ProductsStore store,
        IConfirmDialog confirm,
        IToast toast,
        NavigationManager navigation,
        ILogger<ProductListActions> logger)
    {
        _store = store;
        _confirm = confirm;
        _toast = toast;
        _navigation = navigation;
        _logger = logger;
    }
    
    /// <summary>
    /// 一覧読み込み
    /// </summary>
    public async Task LoadAsync(CancellationToken ct = default)
    {
        try
        {
            await _store.LoadAsync(ct);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "商品一覧の読み込みに失敗しました");
            _toast.Error("データの読み込みに失敗しました");
        }
    }
    
    /// <summary>
    /// ページ切り替え
    /// </summary>
    public async Task LoadPageAsync(int pageNumber, CancellationToken ct = default)
    {
        await _store.LoadPageAsync(pageNumber, ct);
    }
    
    /// <summary>
    /// 新規作成
    /// </summary>
    public void CreateAsync()
    {
        _navigation.NavigateTo("/products/create");
    }
    
    /// <summary>
    /// 編集
    /// </summary>
    public void EditAsync(Guid productId)
    {
        _navigation.NavigateTo($"/products/{productId}/edit");
    }
    
    /// <summary>
    /// 削除(確認ダイアログ付き)
    /// </summary>
    public async Task DeleteAsync(Guid productId, CancellationToken ct = default)
    {
        // 1. 確認ダイアログ
        var confirmed = await _confirm.ShowAsync(
            title: "削除確認",
            message: "この商品を削除してもよろしいですか?",
            confirmText: "削除",
            cancelText: "キャンセル");
        
        if (!confirmed)
        {
            _logger.LogInformation("商品削除がキャンセルされました: {ProductId}", productId);
            return;
        }
        
        // 2. I/O実行(Storeに委譲)
        var success = await _store.DeleteAsync(productId, ct);
        
        // 3. 結果通知
        if (success)
        {
            _toast.Success("商品を削除しました");
            _logger.LogInformation("商品を削除しました: {ProductId}", productId);
        }
        else
        {
            _toast.Error("商品の削除に失敗しました");
            _logger.LogWarning("商品削除に失敗しました: {ProductId}", productId);
        }
    }
    
    /// <summary>
    /// 一括削除
    /// </summary>
    public async Task DeleteBatchAsync(IEnumerable<Guid> productIds, CancellationToken ct = default)
    {
        var ids = productIds.ToList();
        
        if (!ids.Any())
        {
            _toast.Warning("削除する商品が選択されていません");
            return;
        }
        
        var confirmed = await _confirm.ShowAsync(
            title: "一括削除確認",
            message: $"{ids.Count}件の商品を削除してもよろしいですか?",
            confirmText: "削除",
            cancelText: "キャンセル");
        
        if (!confirmed) return;
        
        var result = await _store.DeleteBatchAsync(ids, ct);
        
        _toast.Info($"{result.SuccessCount}件削除、{result.FailureCount}件失敗");
    }
}
```

#### **テスタビリティ**

```csharp
// ✅ PageActionsはI/Oを持たないため、モックなしでテスト可能

public class ProductListActionsTests
{
    [Fact]
    public async Task DeleteAsync_ユーザーがキャンセル_Storeを呼ばない()
    {
        // Arrange
        var storeMock = new Mock<ProductsStore>();
        var confirmMock = new Mock<IConfirmDialog>();
        confirmMock.Setup(x => x.ShowAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>()))
            .ReturnsAsync(false);  // キャンセル
        
        var actions = new ProductListActions(
            storeMock.Object,
            confirmMock.Object,
            Mock.Of<IToast>(),
            Mock.Of<NavigationManager>(),
            Mock.Of<ILogger<ProductListActions>>());
        
        // Act
        await actions.DeleteAsync(Guid.NewGuid());
        
        // Assert
        storeMock.Verify(x => x.DeleteAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()), Times.Never);
    }
}
```

### 7.4 Store(状態管理とI/O)

#### **設計原則**

- **Single Source of Truth**: 状態の単一ソース
- **Immutable State**: 不変状態
- **Scope Management**: 都度スコープ作成
- **Concurrency Control**: 並行制御

#### **実装例**

```csharp
/// <summary>
/// 商品一覧の状態管理とI/O実行
/// Blazor Server: Circuit(接続)単位でScoped
/// </summary>
public sealed class ProductsStore : IDisposable
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<ProductsStore> _logger;
    
    // 並行制御用
    private readonly SemaphoreSlim _gate = new(1, 1);
    private CancellationTokenSource? _cts;
    
    // 状態(不変)
    private ProductsState _state = ProductsState.Empty;
    
    /// <summary>
    /// 状態変更イベント
    /// Smart Componentが購読
    /// </summary>
    public event Func<Task>? OnChangeAsync;
    
    public ProductsStore(
        IServiceScopeFactory scopeFactory,
        ILogger<ProductsStore> logger)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
    }
    
    /// <summary>
    /// 現在の状態を取得(読み取り専用)
    /// </summary>
    public ProductsState GetState() => _state;
    
    /// <summary>
    /// 商品一覧を読み込み
    /// </summary>
    public async Task LoadAsync(CancellationToken ct = default)
    {
        // 並行実行制御: 先行処理中は新規リクエストをブロック
        if (!await _gate.WaitAsync(0, ct))
        {
            _logger.LogDebug("LoadAsyncは既に実行中のためスキップされました");
            return;
        }
        
        // 既存の処理をキャンセル
        _cts?.Cancel();
        _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        
        try
        {
            // 1. ローディング開始
            SetState(_state with { IsLoading = true, ErrorMessage = null });
            
            // 2. 新しいスコープでMediatorを取得(DbContextリーク防止)
            using var scope = _scopeFactory.CreateScope();
            var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
            
            // 3. Queryを実行(CQRS)
            var result = await mediator.Send(
                new GetProductsQuery(_state.CurrentPage, _state.PageSize), 
                _cts.Token);
            
            // 4. 結果を状態に反映
            if (result.IsSuccess)
            {
                SetState(_state with
                {
                    IsLoading = false,
                    Products = result.Value.Items.ToImmutableList(),
                    TotalCount = result.Value.TotalCount,
                    ErrorMessage = null
                });
            }
            else
            {
                SetState(_state with
                {
                    IsLoading = false,
                    ErrorMessage = result.Error
                });
            }
        }
        catch (OperationCanceledException)
        {
            _logger.LogDebug("LoadAsyncがキャンセルされました");
            SetState(_state with { IsLoading = false });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "商品一覧の読み込みに失敗しました");
            SetState(_state with
            {
                IsLoading = false,
                ErrorMessage = "データの読み込みに失敗しました"
            });
        }
        finally
        {
            _gate.Release();
        }
    }
    
    /// <summary>
    /// ページ切り替え
    /// </summary>
    public async Task LoadPageAsync(int pageNumber, CancellationToken ct = default)
    {
        if (pageNumber < 1 || pageNumber > _state.TotalPages)
            return;
        
        SetState(_state with { CurrentPage = pageNumber });
        await LoadAsync(ct);
    }
    
    /// <summary>
    /// 商品を削除
    /// </summary>
    public async Task<bool> DeleteAsync(Guid productId, CancellationToken ct = default)
    {
        try
        {
            // 1. ローディング開始(部分的)
            SetState(_state with { ErrorMessage = null });
            
            // 2. 新しいスコープでCommandを実行
            using var scope = _scopeFactory.CreateScope();
            var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
            
            var command = new DeleteProductCommand(productId);
            var result = await mediator.Send(command, ct);
            
            if (!result.IsSuccess)
            {
                SetState(_state with { ErrorMessage = result.Error });
                return false;
            }
            
            // 3. 成功したら一覧を再読み込み
            await LoadAsync(ct);
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "商品削除に失敗しました: {ProductId}", productId);
            SetState(_state with { ErrorMessage = "削除処理に失敗しました" });
            return false;
        }
    }
    
    /// <summary>
    /// 一括削除
    /// </summary>
    public async Task<(int SuccessCount, int FailureCount)> DeleteBatchAsync(
        IEnumerable<Guid> productIds, 
        CancellationToken ct = default)
    {
        var ids = productIds.ToList();
        var successCount = 0;
        var failureCount = 0;
        
        SetState(_state with { IsLoading = true, ErrorMessage = null });
        
        foreach (var id in ids)
        {
            try
            {
                using var scope = _scopeFactory.CreateScope();
                var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
                
                var result = await mediator.Send(new DeleteProductCommand(id), ct);
                
                if (result.IsSuccess) successCount++;
                else failureCount++;
            }
            catch
            {
                failureCount++;
            }
        }
        
        await LoadAsync(ct);
        return (successCount, failureCount);
    }
    
    /// <summary>
    /// 状態を更新し、購読者に通知
    /// </summary>
    private async void SetState(ProductsState newState)
    {
        _state = newState;
        
        if (OnChangeAsync is null) return;
        
        // すべての購読者に通知
        foreach (var handler in OnChangeAsync.GetInvocationList().Cast<Func<Task>>())
        {
            try
            {
                await handler();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "状態変更通知中にエラーが発生しました");
            }
        }
    }
    
    public void Dispose()
    {
        _cts?.Cancel();
        _cts?.Dispose();
        _gate.Dispose();
    }
}
```

#### **State定義**

```csharp
/// <summary>
/// 商品一覧画面の状態
/// recordによる不変性の保証
/// </summary>
public sealed record ProductsState
{
    public static readonly ProductsState Empty = new();
    
    /// <summary>
    /// 表示中の商品リスト
    /// </summary>
    public ImmutableList<ProductDto> Products { get; init; } = ImmutableList<ProductDto>.Empty;
    
    /// <summary>
    /// ローディング中フラグ
    /// </summary>
    public bool IsLoading { get; init; }
    
    /// <summary>
    /// エラーメッセージ
    /// </summary>
    public string? ErrorMessage { get; init; }
    
    /// <summary>
    /// 現在のページ番号
    /// </summary>
    public int CurrentPage { get; init; } = 1;
    
    /// <summary>
    /// 1ページあたりの件数
    /// </summary>
    public int PageSize { get; init; } = 20;
    
    /// <summary>
    /// 総件数
    /// </summary>
    public int TotalCount { get; init; }
    
    /// <summary>
    /// 総ページ数(計算プロパティ)
    /// </summary>
    public int TotalPages => (int)Math.Ceiling((double)TotalCount / PageSize);
    
    /// <summary>
    /// 選択中の商品ID(一括操作用)
    /// </summary>
    public ImmutableHashSet<Guid> SelectedIds { get; init; } = ImmutableHashSet<Guid>.Empty;
}
```

#### **重要な注意点**

```csharp
// ✅ 都度スコープの重要性(Blazor Server)

// 間違い: Storeに直接DbContextをDI
public class ProductsStore
{
    private readonly AppDbContext _context;  // ❌ 禁止!
    
    public ProductsStore(AppDbContext context)
    {
        _context = context;  // Circuit寿命と同じになり、メモリリーク
    }
}

// 正しい: IServiceScopeFactoryで都度スコープ作成
public class ProductsStore
{
    private readonly IServiceScopeFactory _scopeFactory;  // ✅ 推奨
    
    public async Task LoadAsync(CancellationToken ct)
    {
        using var scope = _scopeFactory.CreateScope();  // ★ 新スコープ
        var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
        // Mediatorのパイプライン内でDbContextが解決される
        // スコープ終了時に自動的にDispose
    }
}
```

### 7.5 Store並行制御の高度なパターン (v2.1改善)

#### 7.5.1 single-flight パターン(同一キー合流)

**versioning + single-flight の組み合わせで重いQueryの多重起動を更に抑制**

```csharp
/// <summary>
/// versioning + single-flight の二段構え並行制御
/// </summary>
public sealed class ProductsStore : IDisposable
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<ProductsStore> _logger;
    
    // 並行制御用
    private readonly SemaphoreSlim _gate = new(1, 1);
    private readonly ConcurrentDictionary<string, Task> _inflightRequests = new();
    private CancellationTokenSource? _cts;
    
    // バージョン管理(連打対策)
    private long _version;
    
    // 状態(不変)
    private ProductsState _state = ProductsState.Empty;
    
    public event Func<Task>? OnChangeAsync;
    
    public ProductsStore(
        IServiceScopeFactory scopeFactory,
        ILogger<ProductsStore> logger)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
    }
    
    public ProductsState GetState() => _state;
    
    /// <summary>
    /// 同一キーの読み込みは合流し、結果を共有(single-flight)
    /// </summary>
    public Task LoadAsync(CancellationToken ct = default)
    {
        const string key = "products-load";  // 固有キー
        
        // ✅ single-flight: 同時リクエストは1つに合流
        return _inflightRequests.GetOrAdd(key, _ => LoadInternalAsync(ct))
            .ContinueWith(t =>
            {
                _inflightRequests.TryRemove(key, out _);  // クリーンアップ
                return t;
            }, ct, TaskContinuationOptions.None, TaskScheduler.Default)
            .Unwrap();
    }
    
    /// <summary>
    /// 実際の読み込み処理(versioning併用)
    /// </summary>
    private async Task LoadInternalAsync(CancellationToken ct)
    {
        // 現在の実行のバージョンを記録
        var currentVersion = Interlocked.Increment(ref _version);
        
        // 既存の処理をキャンセル
        _cts?.Cancel();
        _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        
        await _gate.WaitAsync(_cts.Token);
        try
        {
            // ✅ versioning: 古い実行は結果を破棄
            if (currentVersion != _version)
            {
                _logger.LogDebug("古い実行をスキップ: Version {Current} != {Latest}", 
                    currentVersion, _version);
                return;
            }
            
            SetState(_state with { IsLoading = true, ErrorMessage = null });
            
            // 実際のDB読み込み(重い処理)
            using var scope = _scopeFactory.CreateScope();
            var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
            
            var result = await mediator.Send(
                new GetProductsQuery(_state.CurrentPage, _state.PageSize), 
                _cts.Token);
            
            // ✅ 最新版のみ反映
            if (currentVersion == _version && result.IsSuccess)
            {
                SetState(_state with
                {
                    IsLoading = false,
                    Products = result.Value.Items.ToImmutableList(),
                    TotalCount = result.Value.TotalCount,
                    ErrorMessage = null
                });
            }
            else if (currentVersion == _version)
            {
                SetState(_state with
                {
                    IsLoading = false,
                    ErrorMessage = result.Error
                });
            }
        }
        catch (OperationCanceledException)
        {
            if (currentVersion == _version)
            {
                _logger.LogDebug("LoadAsyncがキャンセルされました");
                SetState(_state with { IsLoading = false });
            }
        }
        catch (Exception ex)
        {
            if (currentVersion == _version)
            {
                _logger.LogError(ex, "商品一覧の読み込みに失敗しました");
                SetState(_state with
                {
                    IsLoading = false,
                    ErrorMessage = "データの読み込みに失敗しました"
                });
            }
        }
        finally
        {
            _gate.Release();
        }
    }
    
    private async void SetState(ProductsState newState)
    {
        // 差分がない場合は通知をスキップ(再描画抑制)
        if (_state.Equals(newState))
        {
            _logger.LogTrace("State has no changes, skipping notification");
            return;
        }
        
        _state = newState;
        
        if (OnChangeAsync is null) return;
        
        // 通知時の例外を飲み込まずログ
        foreach (var handler in OnChangeAsync.GetInvocationList().Cast<Func<Task>>())
        {
            try
            {
                await handler();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "State change notification failed");
                // 例外を再スローせず、ログのみ記録
            }
        }
    }
    
    public void Dispose()
    {
        _cts?.Cancel();
        _cts?.Dispose();
        _gate?.Dispose();
    }
}
```

**効果の比較**:

| パターン | 連打10回 | DB負荷 | UI応答 |
|---------|---------|--------|--------|
| 制御なし | 10回実行 | 10回 | 遅い |
| versioningのみ | 10回実行→1回反映 | 10回 | 速い |
| versioning + single-flight | 1回実行→1回反映 | 1回 | 最速 |

**使い分けガイド**:

```csharp
// 軽いQuery(<100ms): versioningのみで十分
public Task LoadAsync(CancellationToken ct = default)
{
    var currentVersion = Interlocked.Increment(ref _version);
    // ... versioning処理のみ
}

// 重いQuery(>500ms): versioning + single-flight推奨
public Task LoadAsync(CancellationToken ct = default)
{
    return _inflightRequests.GetOrAdd("key", _ => LoadInternalAsync(ct))
        .ContinueWith(/* cleanup */)
        .Unwrap();
}

// 頻繁な更新画面: versioning + デバウンス
private readonly Timer _debounceTimer;
public void TriggerLoad()
{
    _debounceTimer.Change(TimeSpan.FromMilliseconds(300), Timeout.InfiniteTimeSpan);
}
```

#### 7.5.2 SignalR通知のコアレス&デバウンス(嵐対策)

**短時間の複数通知を1回の再読込にまとめる**

```csharp
/// <summary>
/// SignalR通知のデバウンス実装
/// </summary>
public sealed class ProductsStore : IDisposable
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<ProductsStore> _logger;
    private readonly IMemoryCache _memoryCache;
    private readonly IHubConnection _hubConnection;
    
    // デバウンス用
    private readonly Timer _debounceTimer;
    private readonly HashSet<string> _pendingInvalidations = new();
    private readonly object _invalidationLock = new();
    
    // ... 既存のフィールド
    
    public ProductsStore(
        IServiceScopeFactory scopeFactory,
        ILogger<ProductsStore> logger,
        IMemoryCache memoryCache,
        IHubConnection hubConnection)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
        _memoryCache = memoryCache;
        _hubConnection = hubConnection;
        
        // デバウンスタイマーの初期化
        _debounceTimer = new Timer(
            FlushInvalidations, 
            null, 
            Timeout.Infinite, 
            Timeout.Infinite);
        
        // ✅ SignalR Hubから通知を受信
        _hubConnection.On<string>("ProductInvalidated", OnProductInvalidated);
        _hubConnection.On<Guid>("ProductDeleted", OnProductDeleted);
        _hubConnection.On<Guid>("ProductUpdated", OnProductUpdated);
    }
    
    /// <summary>
    /// キャッシュ無効化通知の受信
    /// </summary>
    private void OnProductInvalidated(string cacheKey)
    {
        lock (_invalidationLock)
        {
            _pendingInvalidations.Add(cacheKey);
            
            // ✅ デバウンス: 500ms以内の通知はまとめる
            _debounceTimer.Change(
                TimeSpan.FromMilliseconds(500), 
                Timeout.InfiniteTimeSpan);
        }
    }
    
    private void OnProductDeleted(Guid productId)
    {
        // 細粒度のキャッシュ無効化
        OnProductInvalidated($"Product:{productId}");
        OnProductInvalidated("ProductList");  // 一覧も無効化
    }
    
    private void OnProductUpdated(Guid productId)
    {
        OnProductInvalidated($"Product:{productId}");
        OnProductInvalidated("ProductList");
    }
    
    /// <summary>
    /// 溜まった無効化通知を一括処理
    /// </summary>
    private async void FlushInvalidations(object? state)
    {
        HashSet<string> keysToInvalidate;
        
        lock (_invalidationLock)
        {
            if (_pendingInvalidations.Count == 0) return;
            
            keysToInvalidate = new HashSet<string>(_pendingInvalidations);
            _pendingInvalidations.Clear();
        }
        
        // ✅ コアレス: 複数のキーを一度に処理
        _logger.LogInformation(
            "Invalidating {Count} cache keys: {Keys}", 
            keysToInvalidate.Count, 
            string.Join(", ", keysToInvalidate));
        
        foreach (var key in keysToInvalidate)
        {
            _memoryCache.Remove(key);
        }
        
        // ✅ 該当する画面のみ再読込(全リロードではない)
        if (keysToInvalidate.Contains("ProductList"))
        {
            try
            {
                await LoadAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "SignalR通知後の再読込に失敗しました");
            }
        }
    }
    
    public void Dispose()
    {
        _debounceTimer?.Dispose();
        _cts?.Cancel();
        _cts?.Dispose();
        _gate?.Dispose();
    }
}
```

**無効化キーの規約(重要)**:

```csharp
// ✅ GOOD: 細粒度のキー(ユーザー固有)
var cacheKey = $"GetProductQuery:{currentUserId}:Product:{productId}";
await _hubConnection.SendAsync("ProductInvalidated", cacheKey);

// ❌ BAD: 粗いキー(全員に影響)
await _hubConnection.SendAsync("ProductInvalidated", "AllProducts");  // 全ユーザーに影響
```

**効果測定**:

| シナリオ | デバウンス前 | デバウンス後 |
|---------|------------|------------|
| 10件の連続更新通知 | 10回再描画 | 1回再描画 |
| 100msごとに5通知 | 5回再描画 | 1回再描画(500ms後) |
| 分散した通知 | N回再描画 | N回再描画(変化なし) |

**実装チェックリスト**:

- [ ] キャッシュキーにユーザーID/テナントIDを含める
- [ ] デバウンス時間は画面の更新頻度に応じて調整(300-1000ms)
- [ ] 細粒度の無効化キーを使用(全体キャッシュクリアは避ける)
- [ ] SignalR再接続時の再購読処理を実装
- [ ] 無効化ログを出力(トラブルシューティング用)

---
