# 12. パフォーマンス最適化

[← 目次に戻る](00_README.md)

---

## 12. パフォーマンス最適化

### 12.1 Blazor Server固有の最適化

#### **1. レンダリング最適化**

```csharp
// ✅ @key ディレクティブを使用した効率的な差分レンダリング
@foreach (var product in State.Products)
{
    <ProductCard @key="product.Id" Product="@product" ... />
}

// ✅ ShouldRender オーバーライド
@code {
    protected override bool ShouldRender()
    {
        // 特定の条件でのみ再描画
        return State.IsLoading || State.Products.Any();
    }
}

// ✅ Virtualize コンポーネント(大量データ)
<Virtualize Items="@State.Products" Context="product" ItemSize="100">
    <ProductCard Product="@product" ... />
</Virtualize>
```

#### **2. Circuit管理**

```csharp
// Program.cs
builder.Services.AddServerSideBlazor(options =>
{
    // Circuit制御
    options.DetailedErrors = builder.Environment.IsDevelopment();
    options.DisconnectedCircuitMaxRetained = 100;
    options.DisconnectedCircuitRetentionPeriod = TimeSpan.FromMinutes(3);
    options.JSInteropDefaultCallTimeout = TimeSpan.FromMinutes(1);
    options.MaxBufferedUnacknowledgedRenderBatches = 10;
});
```

#### **3. State管理の最適化**

```csharp
// ❌ アンチパターン: 巨大なStateオブジェクトの保持
public record ProductsState
{
    public ImmutableList<ProductDto> AllProducts { get; init; } // 10,000ä»¶
    public ImmutableList<OrderDto> AllOrders { get; init; }     // 10,000ä»¶
    // メモリ圧とレンダリングコストが大
}

// ✅ 推奨: ページングと投影
public record ProductsState
{
    public ImmutableList<ProductDto> CurrentPageProducts { get; init; } // 20ä»¶
    public int TotalCount { get; init; }
    public int CurrentPage { get; init; }
    public int PageSize { get; init; } = 20;
}
```

### 12.2 データベースクエリ最適化

```csharp
// ✅ 読み取り専用ビューの活用
CREATE VIEW ProductListView WITH SCHEMABINDING AS
SELECT 
    p.Id,
    p.Name,
    p.Price,
    p.Currency,
    p.Stock,
    p.Status,
    COUNT_BIG(i.Id) as ImageCount
FROM dbo.Products p
LEFT JOIN dbo.ProductImages i ON p.Id = i.ProductId
WHERE p.Status != 'Deleted'
GROUP BY p.Id, p.Name, p.Price, p.Currency, p.Stock, p.Status;

CREATE UNIQUE CLUSTERED INDEX IX_ProductListView_Id ON ProductListView(Id);

// Dapperで高速取得
public async Task<IEnumerable<ProductDto>> GetProductListAsync(...)
{
    const string sql = @"
        SELECT * FROM ProductListView
        ORDER BY Name
        OFFSET @Offset ROWS FETCH NEXT @PageSize ROWS ONLY";
    
    return await _connection.QueryAsync<ProductDto>(sql, ...);
}
```

### 12.3 キャッシュ戦略

```csharp
// ✅ 分散キャッシュ設定
builder.Services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = builder.Configuration.GetConnectionString("Redis");
    options.InstanceName = "YourApp:";
});

// ✅ Query別のキャッシュ戦略
public record GetProductsQuery(...) : IQuery<...>, ICacheableQuery
{
    public string CacheKey => $"products_{Page}_{PageSize}";
    public TimeSpan CacheDuration => TimeSpan.FromMinutes(5);
}

public record GetProductDetailQuery(Guid Id) : IQuery<...>, ICacheableQuery
{
    public string CacheKey => $"product_detail_{Id}";
    public TimeSpan CacheDuration => TimeSpan.FromMinutes(10);
}

// ✅ キャッシュ無効化
public class ProductDeletedEventHandler : INotificationHandler<ProductDeletedEvent>
{
    private readonly IDistributedCache _cache;
    
    public async Task Handle(ProductDeletedEvent @event, CancellationToken ct)
    {
        // 関連キャッシュを削除
        await _cache.RemoveAsync($"product_detail_{@event.ProductId.Value}", ct);
        
        // リストキャッシュも削除(全ページ)
        for (int page = 1; page <= 10; page++)
        {
            await _cache.RemoveAsync($"products_{page}_20", ct);
        }
    }
}
```

### 12.4 Query最適化チェックリスト (v2.1改善)

**画面専用DTOの徹底とレビューを効率化する固定パターン**

#### 12.4.1 Query最適化の必須パターン

```csharp
// ✅ パターン1: ページングのCOUNT分離(FAST COUNT)

// ❌ BAD: COUNT(*)を毎回実行
public async Task<PagedResult<ProductDto>> GetProductsAsync(int page, int pageSize)
{
    var total = await _context.Products.CountAsync();  // 重い
    var items = await _context.Products
        .Skip((page - 1) * pageSize)
        .Take(pageSize)
        .ToListAsync();
    
    return new PagedResult<ProductDto>(items, total);
}

// ✅ GOOD: インデックス化されたビューでCOUNT最適化
CREATE VIEW ProductListSummary WITH SCHEMABINDING AS
SELECT 
    COUNT_BIG(*) as TotalCount
FROM dbo.Products
WHERE Status != 'Deleted';

CREATE UNIQUE CLUSTERED INDEX IX_ProductListSummary ON ProductListSummary(TotalCount);

// Dapperで取得
public async Task<PagedResult<ProductDto>> GetProductsAsync(int page, int pageSize)
{
    // FAST COUNT: インデックスから瞬時取得
    var total = await _connection.ExecuteScalarAsync<int>(
        "SELECT TotalCount FROM ProductListSummary");
    
    // データ取得(投影最適化)
    var items = await _connection.QueryAsync<ProductDto>(@"
        SELECT Id, Name, Price, Stock, Status 
        FROM Products 
        WHERE Status != 'Deleted'
        ORDER BY Name
        OFFSET @Offset ROWS FETCH NEXT @PageSize ROWS ONLY",
        new { Offset = (page - 1) * pageSize, PageSize = pageSize });
    
    return new PagedResult<ProductDto>(items, total);
}
```

```csharp
// ✅ パターン2: 投影の固定SQL(Dapper活用)

// ❌ BAD: EF Coreで全カラムを取得してからSelect
public async Task<IEnumerable<ProductListItemDto>> GetProductsAsync()
{
    return await _context.Products
        .Include(p => p.Images)  // 不要なJOIN
        .Include(p => p.Category)  // 不要なJOIN
        .Select(p => new ProductListItemDto  // 投影が遅い
        {
            Id = p.Id,
            Name = p.Name,
            Price = p.Price
        })
        .ToListAsync();
}

// ✅ GOOD: Dapperで必要なカラムのみ取得
public async Task<IEnumerable<ProductListItemDto>> GetProductsAsync()
{
    const string sql = @"
        SELECT 
            Id,
            Name,
            Price,
            Stock,
            Status
        FROM Products
        WHERE Status != 'Deleted'
        ORDER BY Name";
    
    return await _connection.QueryAsync<ProductListItemDto>(sql);
}
```

#### 12.4.2 画面専用DTOの設計ガイド

```csharp
// ✅ GOOD: 画面ごとに専用DTO

// 一覧画面用(最小限のフィールド)
public record ProductListItemDto(
    Guid Id,
    string Name,
    decimal Price,
    string Currency,
    int Stock,
    ProductStatus Status
);

// 詳細画面用(全フィールド + 関連データ)
public record ProductDetailDto(
    Guid Id,
    string Name,
    string Description,
    decimal Price,
    string Currency,
    int Stock,
    ProductStatus Status,
    IReadOnlyList<ProductImageDto> Images,
    CategoryDto Category
);

// 編集フォーム用(編集可能フィールドのみ)
public record ProductEditDto(
    Guid Id,
    string Name,
    string Description,
    decimal Price,
    int Stock
);
```

#### 12.4.3 レビュー用チェックリスト

**Pull Requestレビュー時に以下を確認**:

| 項目 | チェック内容 | ❌NG例 | ✅OK例 |
|------|------------|--------|--------|
| **1. DTO専用性** | 画面専用DTOを使用しているか | Entityを直接返却 | 画面用DTOを作成 |
| **2. COUNT最適化** | ページングでFAST COUNTを使用しているか | COUNT(*)毎回実行 | インデックス化ビュー |
| **3. 投影最適化** | 必要なカラムのみSELECTしているか | SELECT * | SELECT Id, Name, ... |
| **4. JOIN最小化** | 不要なInclude/JOINがないか | .Include(x => x.All) | 必要な列のみJOIN |
| **5. N+1問題** | ループ内でクエリを実行していないか | foreach内でQuery | 一括取得+辞書化 |
| **6. インデックス** | WHERE/ORDER BYにインデックスがあるか | インデックスなし | 適切なインデックス |
| **7. Dapper活用** | 読み取りにDapperを使用しているか | EF Core Select | Dapper QueryAsync |

#### 12.4.4 実装例(ベストプラクティス)

```csharp
/// <summary>
/// 商品一覧Query(最適化版)
/// </summary>
public record GetProductsQuery(int Page = 1, int PageSize = 20) 
    : IQuery<PagedResult<ProductListItemDto>>;

public class GetProductsQueryHandler 
    : IRequestHandler<GetProductsQuery, PagedResult<ProductListItemDto>>
{
    private readonly IDbConnection _connection;
    
    public async Task<PagedResult<ProductListItemDto>> Handle(
        GetProductsQuery request, 
        CancellationToken ct)
    {
        // ✅ FAST COUNT: インデックス化されたビューから取得
        var totalCount = await _connection.ExecuteScalarAsync<int>(
            "SELECT TotalCount FROM ProductListSummary");
        
        // ✅ 投影最適化: 必要なカラムのみ取得(Dapper)
        const string sql = @"
            SELECT 
                p.Id,
                p.Name,
                p.Price,
                p.Currency,
                p.Stock,
                p.Status
            FROM Products p
            WHERE p.Status != 'Deleted'
            ORDER BY p.Name
            OFFSET @Offset ROWS FETCH NEXT @PageSize ROWS ONLY";
        
        var items = await _connection.QueryAsync<ProductListItemDto>(
            sql,
            new 
            { 
                Offset = (request.Page - 1) * request.PageSize, 
                PageSize = request.PageSize 
            });
        
        return new PagedResult<ProductListItemDto>(items, totalCount);
    }
}
```

### 12.5 観測可能性(Observability)の実装 (v2.1改善)

**CorrelationIdとMessageIdで障害追跡を高速化**

#### 12.5.1 CorrelationIdの貫通実装

```csharp
// 1. CorrelationId用のサービス
public interface ICorrelationIdService
{
    string CorrelationId { get; }
    void SetCorrelationId(string correlationId);
}

public class CorrelationIdService : ICorrelationIdService
{
    private static readonly AsyncLocal<string?> _correlationId = new();
    
    public string CorrelationId => 
        _correlationId.Value ?? throw new InvalidOperationException("CorrelationId not set");
    
    public void SetCorrelationId(string correlationId)
    {
        _correlationId.Value = correlationId;
    }
}

// 2. Blazor Middleware(CorrelationId生成)
public class CorrelationIdMiddleware
{
    private readonly RequestDelegate _next;
    
    public async Task InvokeAsync(
        HttpContext context, 
        ICorrelationIdService correlationIdService)
    {
        // ヘッダーから取得、なければ生成
        var correlationId = context.Request.Headers["X-Correlation-ID"].FirstOrDefault()
            ?? Guid.NewGuid().ToString("N");
        
        correlationIdService.SetCorrelationId(correlationId);
        
        // レスポンスヘッダーにも追加
        context.Response.Headers.Add("X-Correlation-ID", correlationId);
        
        await _next(context);
    }
}

// 3. LoggingBehaviorに統合
public class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
{
    private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;
    private readonly ICorrelationIdService _correlationId;
    
    public async Task<TResponse> Handle(
        TRequest request, 
        RequestHandlerDelegate<TResponse> next, 
        CancellationToken ct)
    {
        var requestName = typeof(TRequest).Name;
        var correlationId = _correlationId.CorrelationId;
        
        // ✅ CorrelationIdをログに含める
        using (_logger.BeginScope(new Dictionary<string, object>
        {
            ["CorrelationId"] = correlationId,
            ["RequestName"] = requestName
        }))
        {
            _logger.LogInformation(
                "[{CorrelationId}] 処理開始: {RequestName}",
                correlationId,
                requestName);
            
            var stopwatch = Stopwatch.StartNew();
            
            try
            {
                var response = await next();
                stopwatch.Stop();
                
                _logger.LogInformation(
                    "[{CorrelationId}] 処理完了: {RequestName} 実行時間: {ElapsedMs}ms",
                    correlationId,
                    requestName,
                    stopwatch.ElapsedMilliseconds);
                
                return response;
            }
            catch (Exception ex)
            {
                stopwatch.Stop();
                
                _logger.LogError(ex,
                    "[{CorrelationId}] 処理失敗: {RequestName} 実行時間: {ElapsedMs}ms",
                    correlationId,
                    requestName,
                    stopwatch.ElapsedMilliseconds);
                
                throw;
            }
        }
    }
}

// 4. Outboxにも統合
public class OutboxMessage
{
    public Guid Id { get; set; }
    public string EventType { get; set; } = default!;
    public string PayloadJson { get; set; } = default!;
    public string CorrelationId { get; set; } = default!;  // ✅ 追加
    public DateTime CreatedAt { get; set; }
    public OutboxStatus Status { get; set; }
}

// 5. OutboxDispatcherでログ出力
public class OutboxDispatcher : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            var messages = await _outboxRepository.GetPendingMessagesAsync(ct);
            
            foreach (var message in messages)
            {
                using (_logger.BeginScope(new Dictionary<string, object>
                {
                    ["CorrelationId"] = message.CorrelationId,  // ✅ 貫通
                    ["MessageId"] = message.Id
                }))
                {
                    _logger.LogInformation(
                        "[{CorrelationId}][{MessageId}] Outboxメッセージ配信開始: {EventType}",
                        message.CorrelationId,
                        message.Id,
                        message.EventType);
                    
                    // ... 配信処理
                }
            }
        }
    }
}
```

#### 12.5.2 Application Insightsとの統合

```csharp
// Program.cs
builder.Services.AddApplicationInsightsTelemetry();

builder.Services.Configure<TelemetryConfiguration>(config =>
{
    // CorrelationIdをカスタムプロパティに追加
    config.TelemetryInitializers.Add(new CorrelationIdTelemetryInitializer());
});

// CorrelationIdTelemetryInitializer
public class CorrelationIdTelemetryInitializer : ITelemetryInitializer
{
    private readonly ICorrelationIdService _correlationId;
    
    public void Initialize(ITelemetry telemetry)
    {
        if (telemetry is ISupportProperties propTelemetry)
        {
            propTelemetry.Properties["CorrelationId"] = _correlationId.CorrelationId;
        }
    }
}
```

**追跡の流れ**:

```
[UI Request]
    ↓ X-Correlation-ID: abc123
[Command Handler] ← Log: [abc123] SaveProductCommand開始
    ↓
[Transaction] ← Log: [abc123] トランザクション開始
    ↓
[Domain Event] ← Log: [abc123] ProductCreatedEvent発行
    ↓
[Outbox] ← Log: [abc123][msg-456] Outboxメッセージ登録
    ↓ (非同期)
[Outbox Dispatcher] ← Log: [abc123][msg-456] 配信開始
    ↓
[SignalR] ← Log: [abc123][msg-456] SignalR通知送信
```

**障害追跡クエリ例(Application Insights)**:

```kusto
// CorrelationIdで全ログを追跡
traces
| where customDimensions.CorrelationId == "abc123"
| project timestamp, message, severityLevel
| order by timestamp asc

// エラーが発生したCorrelationIdを抽出
exceptions
| where timestamp > ago(1h)
| extend CorrelationId = tostring(customDimensions.CorrelationId)
| summarize ErrorCount = count() by CorrelationId
| order by ErrorCount desc
```

**実装チェックリスト**:

- [ ] CorrelationIdServiceを実装しScoped登録
- [ ] Middlewareで生成/ヘッダー追加
- [ ] LoggingBehaviorでログスコープに追加
- [ ] Outboxメッセージに含める
- [ ] Application Insights統合(オプション)
- [ ] 構造化ログ(JSON)で出力
- [ ] 本番環境でログレベルInformation以上

---

