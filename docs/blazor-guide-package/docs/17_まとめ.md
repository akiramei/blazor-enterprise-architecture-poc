# 17. まとめ

[← 目次に戻る](00_README.md)

---

## 17. まとめ

### 15.1 このアーキテクチャの核心

このアーキテクチャは以下の原則に基づいています:

1. **関心事の分離**: UI、Application、Domain、Infrastructureの明確な責務分割
2. **不変性**: State管理における予測可能性
3. **明示的な副作用**: PageActions → Store → Mediator の一方向フロー
4. **スコープ健全性**: Blazor Serverでの適切なDbContext管理
5. **信頼性**: Idempotency、Inbox、SAGAによる堅牢性
6. **拡張性**: Vertical Slice Architectureによる機能単位の独立性

### 15.2 適用の段階的アプローチ

#### **Phase 1: 基礎(1-2週間)**
- Smart/Dumb分離
- Store + PageActions導入
- MediatR + 基本Behaviors

#### **Phase 2: CQRS(2-3週間)**
- Command/Query分離
- ReadDao導入
- キャッシュ戦略

#### **Phase 3: 信頼性(1ヶ月)**
- Idempotency実装
- Inbox実装
- 重要フローにSAGA適用

#### **Phase 4: 最適化(継続)**
- パフォーマンスチューニング
- テストカバレッジ向上
- 監視・メトリクス強化

### 15.3 成功の指標

- **変更容易性**: 新機能追加が既存コードに影響しない
- **テストカバレッジ**: 60%以上(Unit + Integration)
- **バグ発生率**: 本番環境での重大バグ < 1件/月
- **パフォーマンス**: 主要画面のロード時間 < 2秒
- **可用性**: 99.9%以上のアップタイム

### 15.4 継続的改善

```csharp
// ✅ 定期的なアーキテクチャレビュー
// - 四半期ごとに技術的負債を評価
// - 新しいパターン・ライブラリの評価
// - チームからのフィードバック収集
// - メトリクスに基づく改善
```

### 15.5 参考資料

- **Domain-Driven Design**: Eric Evans
- **Clean Architecture**: Robert C. Martin
- **Vertical Slice Architecture**: Jimmy Bogard
- **MediatR Documentation**: https://github.com/jbogard/MediatR
- **Blazor Documentation**: https://learn.microsoft.com/blazor

---

## 付録A: トラブルシューティング

### A.1 よくある問題と解決策

#### **問題: DbContextのメモリリーク**

```csharp
// ❌ 原因
builder.Services.AddScoped<AppDbContext>();  // Circuit寿命と同じ

// ✅ 解決策
// Storeで都度スコープを作成
using var scope = _scopeFactory.CreateScope();
var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
```

#### **問題: SignalRの再接続でメッセージ重複**

```csharp
// ✅ 解決策: Inbox Patternで重複排除
public async Task Handle(ProductDeletedIntegrationEvent evt, ...)
{
    if (await _inboxStore.IsProcessedAsync(evt.EventId, ct))
        return;  // 既に処理済み
    
    // ... 処理
}
```

#### **問題: 並行操作でのデータ不整合**

```csharp
// ✅ 解決策: 楽観的同時実行制御
public class Product : AggregateRoot<ProductId>
{
    public byte[] RowVersion { get; private set; }  // EF Coreが自動更新
}

// EF Core設定
builder.Property(p => p.RowVersion)
    .IsRowVersion();
```

---

**このガイドが、Blazor業務アプリケーションの成功に貢献することを願っています。**

**バージョン履歴**:
- v1.0 (2025-10): 初版リリース
- v2.0 (2025-10): Phase2改善版リリース

---

# Blazor Architecture Guide v2.0 - Phase2 改善内容

## 7.3.1 PageActions コーディング規約の明文化 (v2.0新規追加)

### 許可される操作と禁止される操作

```csharp
// ✅ 許可される操作

public class ProductListActions
{
    // 1. Store メソッドの呼び出し
    await _store.LoadAsync(ct);
    await _store.DeleteAsync(id, ct);
    
    // 2. 確認ダイアログの表示
    var confirmed = await _confirm.ShowAsync("削除しますか?");
    
    // 3. トースト通知の表示
    _toast.Success("削除しました");
    _toast.Error("エラーが発生しました");
    
    // 4. ページナビゲーション
    _navigation.NavigateTo("/products");
    
    // 5. ロギング出力
    _logger.LogInformation("操作完了");
}

// ❌ 禁止される操作

public class ProductListActions
{
    // 1. 直接的なHTTP通信(禁止)
    var response = await _httpClient.GetAsync("/api/products");  // ❌ 禁止
    
    // 2. LocalStorage / SessionStorage
    await _localStorage.SetItemAsync("key", value);  // ❌ 禁止
    
    // 3. Clipboard 操作
    await _clipboard.WriteTextAsync(text);  // ❌ 禁止
    
    // 4. File I/O
    var bytes = await File.ReadAllBytesAsync(path);  // ❌ 禁止
    
    // 5. JavaScript相互運用(Store経由で実行すること)
    await _jsRuntime.InvokeVoidAsync("download", data);  // ❌ 禁止
    
    // 6. ビジネスロジックの実装(禁止)
    if (product.Stock > 0)  // ❌ 禁止: ドメインルール
    {
        return Result.Fail("在庫があります");
    }
}

// ✅ 正しい例: LocalStorageを使う場合はStoreに委譲

// PageActions
public async Task SaveFiltersAsync()
{
    var filters = GetCurrentFilters();
    await _store.SaveFiltersToLocalAsync(filters);  // Store に委譲
}

// Store
public async Task SaveFiltersToLocalAsync(ProductFilters filters)
{
    await _localStorage.SetItemAsync("product-filters", filters);
}
```

### コーディング規約チェックリスト

| 項 目 | 許可 | 理由 |
|------|------|------|
| Store 呼び出し | ✅ | 必須 |
| Dialog / Toast | ✅ | UI フィードバック |
| Navigation | ✅ | 画面遷移 |
| Logger | ✅ | 操作ログ |
| HTTP 通信 | ❌ | Store に委譲 |
| LocalStorage | ❌ | Store に委譲 |
| Clipboard | ❌ | Store に委譲 |
| File I/O | ❌ | Store に委譲 |
| JS Interop | ❌ | Store に委譲 |
| ビジネスロジック | ❌ | Handler / Domain に委譲 |

---

## 7.4.1 Store 並行制御パターンの強化 (v2.0改善)

### 最新版のみ反映パターン(Versioning)

```csharp
/// <summary>
/// 商品一覧の状態管理とI/O実行
/// 並行制御: Versioning + SemaphoreSlim
/// </summary>
public sealed class ProductsStore : IDisposable
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<ProductsStore> _logger;
    
    // 並行制御用
    private readonly SemaphoreSlim _gate = new(1, 1);
    private CancellationTokenSource? _cts;
    
    // バージョン管理(連打対策)
    private long _version;
    
    // 状態(不変)
    private ProductsState _state = ProductsState.Empty;
    
    /// <summary>
    /// State変更通知
    /// </summary>
    public event Func<Task>? OnChangeAsync;
    
    /// <summary>
    /// 現在の状態を取得
    /// </summary>
    public ProductsState GetState() => _state;
    
    /// <summary>
    /// 次のバージョン番号を生成(スレッドセーフ)
    /// </summary>
    private long NextVersion() => Interlocked.Increment(ref _version);
    
    /// <summary>
    /// 商品一覧を読み込む(連打対策付き)
    /// </summary>
    public async Task LoadAsync(CancellationToken ct = default)
    {
        // 現在の実行のバージョンを記録
        var currentVersion = NextVersion();
        
        // 既存の処理をキャンセル
        _cts?.Cancel();
        _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        
        // 並行制御
        await _gate.WaitAsync(_cts.Token);
        try
        {
            SetState(_state with { IsLoading = true, ErrorMessage = null });
            
            // 都度スコープ作成
            using var scope = _scopeFactory.CreateScope();
            var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
            
            var result = await mediator.Send(new GetProductsQuery(), _cts.Token);
            
            // 古い結果は捨てる(連打で新しい処理が開始された場合)
            if (currentVersion != _version)
            {
                _logger.LogDebug("古い実行結果を破棄: Version {CurrentVersion} != {LatestVersion}", 
                    currentVersion, _version);
                return;
            }
            
            if (result.IsSuccess)
            {
                SetState(_state with 
                { 
                    Products = result.Value.ToImmutableList(),
                    IsLoading = false 
                });
            }
            else
            {
                SetState(_state with 
                { 
                    IsLoading = false,
                    ErrorMessage = result.Error 
                });
            }
        }
        catch (OperationCanceledException) when (_cts.Token.IsCancellationRequested)
        {
            // キャンセル時は最新版のみ状態更新
            if (currentVersion == _version)
            {
                SetState(_state with { IsLoading = false });
            }
            _logger.LogInformation("読み込みがキャンセルされました");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "商品一覧の読み込みに失敗しました");
            if (currentVersion == _version)
            {
                SetState(_state with 
                { 
                    IsLoading = false,
                    ErrorMessage = "データの読み込みに失敗しました" 
                });
            }
        }
        finally
        {
            _gate.Release();
        }
    }
    
    /// <summary>
    /// 商品を削除
    /// </summary>
    public async Task<bool> DeleteAsync(Guid productId, CancellationToken ct = default)
    {
        await _gate.WaitAsync(ct);
        try
        {
            SetState(_state with { IsLoading = true });
            
            using var scope = _scopeFactory.CreateScope();
            var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
            
            var result = await mediator.Send(new DeleteProductCommand(productId), ct);
            
            if (result.IsSuccess)
            {
                // 成功時は再読み込み
                await LoadAsync(ct);
                return true;
            }
            else
            {
                SetState(_state with 
                { 
                    IsLoading = false,
                    ErrorMessage = result.Error 
                });
                return false;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "商品削除に失敗しました: {ProductId}", productId);
            SetState(_state with 
            { 
                IsLoading = false,
                ErrorMessage = "商品の削除に失敗しました" 
            });
            return false;
        }
        finally
        {
            _gate.Release();
        }
    }
    
    /// <summary>
    /// 状態を更新し通知(差分なしの場合はスキップ)
    /// </summary>
    private void SetState(ProductsState newState)
    {
        // 差分がない場合は通知をスキップ(再描画抑制)
        if (_state.Equals(newState))
        {
            _logger.LogTrace("State has no changes, skipping notification");
            return;
        }
        
        _state = newState;
        
        // 通知時の例外を飲み込まずログ
        if (OnChangeAsync != null)
        {
            try
            {
                _ = OnChangeAsync.Invoke();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "State change notification failed");
                // 例外を再スローせず、ログのみ記録
            }
        }
    }
    
    public void Dispose()
    {
        _cts?.Cancel();
        _cts?.Dispose();
        _gate?.Dispose();
    }
}

/// <summary>
/// State定義(Equalsオーバーライドで差分判定)
/// </summary>
public record ProductsState
{
    public ImmutableList<ProductDto> Products { get; init; } = ImmutableList<ProductDto>.Empty;
    public bool IsLoading { get; init; }
    public string? ErrorMessage { get; init; }
    public int CurrentPage { get; init; } = 1;
    public int TotalPages { get; init; } = 1;
    public int TotalCount { get; init; }
    
    public static ProductsState Empty => new();
    
    // record型は自動的にEqualsが実装されるが、
    // ImmutableListの比較は参照比較なので、必要に応じてカスタム実装
    public virtual bool Equals(ProductsState? other)
    {
        if (other is null) return false;
        if (ReferenceEquals(this, other)) return true;
        
        return Products.SequenceEqual(other.Products) &&
               IsLoading == other.IsLoading &&
               ErrorMessage == other.ErrorMessage &&
               CurrentPage == other.CurrentPage &&
               TotalPages == other.TotalPages &&
               TotalCount == other.TotalCount;
    }
    
    public override int GetHashCode()
    {
        return HashCode.Combine(Products.Count, IsLoading, ErrorMessage, CurrentPage, TotalPages, TotalCount);
    }
}
```

### 並行制御のポイント

1. **Versioning**: 連番を振り、完了時に番号一致のみ反映
2. **CancellationToken**: 古い処理を明示的にキャンセル
3. **SemaphoreSlim**: 同時実行を1つに制限
4. **差分判定**: State.Equals で不要な再描画を抑制
5. **例外ログ**: 通知ハンドラの例外を飲み込まずログ出力

---

## 8.3.1 Transactionスコープの厳密化 (v2.0改善)

### Pipeline 登録(Command/Query 分離)

```csharp
// Program.cs

var builder = WebApplication.CreateBuilder(args);

// MediatR 登録
builder.Services.AddMediatR(cfg =>
{
    cfg.RegisterServicesFromAssembly(typeof(Program).Assembly);
});

// Pipeline Behaviors の登録(順序重要)
// 全てのリクエスト(Query + Command)に適用
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(AuthorizationBehavior<,>));

// Query のみに適用(Caching)
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(CachingBehavior<,>));

// Command のみに適用(Idempotency, Transaction)
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(IdempotencyBehaviorForCommands<,>));
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(TransactionBehaviorForCommands<,>));

var app = builder.Build();
```

### TransactionBehavior (Command 専用)

```csharp
/// <summary>
/// Transaction Behavior - ICommand のみに適用
/// </summary>
public class TransactionBehaviorForCommands<TRequest, TResponse> 
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : ICommand<TResponse>  // 制約で Command のみ
{
    private readonly AppDbContext _dbContext;
    private readonly ILogger<TransactionBehaviorForCommands<TRequest, TResponse>> _logger;
    
    public TransactionBehaviorForCommands(
        AppDbContext dbContext,
        ILogger<TransactionBehaviorForCommands<TRequest, TResponse>> logger)
    {
        _dbContext = dbContext;
        _logger = logger;
    }
    
    public async Task<TResponse> Handle(
        TRequest request, 
        RequestHandlerDelegate<TResponse> next, 
        CancellationToken ct)
    {
        // Query は通過(この Behavior には到達しない)
        
        var typeName = typeof(TRequest).Name;
        
        _logger.LogInformation("トランザクション開始: {CommandName}", typeName);
        
        // Transaction 開始
        await using var transaction = await _dbContext.Database.BeginTransactionAsync(ct);
        
        try
        {
            var response = await next();
            
            // Commit
            await transaction.CommitAsync(ct);
            
            _logger.LogInformation("トランザクション完了: {CommandName}", typeName);
            
            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "トランザクションロールバック: {CommandName}", typeName);
            
            // Rollback
            await transaction.RollbackAsync(ct);
            
            throw;
        }
    }
}
```

### IdempotencyBehavior (Command 専用)

```csharp
/// <summary>
/// Idempotency Behavior - ICommand のみに適用
/// </summary>
public class IdempotencyBehaviorForCommands<TRequest, TResponse> 
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : ICommand<TResponse>, IIdempotentCommand  // 両方の制約
{
    private readonly IIdempotencyStore _idempotencyStore;
    private readonly ILogger<IdempotencyBehaviorForCommands<TRequest, TResponse>> _logger;
    
    public IdempotencyBehaviorForCommands(
        IIdempotencyStore idempotencyStore,
        ILogger<IdempotencyBehaviorForCommands<TRequest, TResponse>> logger)
    {
        _idempotencyStore = idempotencyStore;
        _logger = logger;
    }
    
    public async Task<TResponse> Handle(
        TRequest request, 
        RequestHandlerDelegate<TResponse> next, 
        CancellationToken ct)
    {
        var idempotencyKey = request.IdempotencyKey;
        
        // 既に処理済みかチェック
        var existingResult = await _idempotencyStore.GetAsync<TResponse>(idempotencyKey, ct);
        if (existingResult != null)
        {
            _logger.LogInformation("冪等性: 既存の結果を返却 - {IdempotencyKey}", idempotencyKey);
            return existingResult;
        }
        
        // 新規処理
        var response = await next();
        
        // 結果を保存
        await _idempotencyStore.SaveAsync(idempotencyKey, response, ct);
        
        _logger.LogInformation("冪等性: 新規処理完了 - {IdempotencyKey}", idempotencyKey);
        
        return response;
    }
}

/// <summary>
/// 冪等性が必要な Command のマーカーインターフェース
/// </summary>
public interface IIdempotentCommand
{
    string IdempotencyKey { get; }
}
```

### Command と Query の定義

```csharp
/// <summary>
/// Command マーカーインターフェース
/// Transaction, Idempotency が適用される
/// </summary>
public interface ICommand<out TResponse> : IRequest<TResponse>
{
}

/// <summary>
/// Query マーカーインターフェース
/// Caching が適用される(Transaction は適用されない)
/// </summary>
public interface IQuery<out TResponse> : IRequest<TResponse>
{
}

/// <summary>
/// Cacheable Query マーカーインターフェース
/// </summary>
public interface ICacheableQuery<out TResponse> : IQuery<TResponse>
{
    string CacheKey { get; }
    TimeSpan CacheDuration { get; }
}
```

### 使用例

```csharp
// Command の例(Transaction 適用)
public sealed record DeleteProductCommand(Guid ProductId) : ICommand<Result>;

// Command with Idempotency の例
public sealed record CreateOrderCommand(
    Guid OrderId,
    string IdempotencyKey
) : ICommand<Result<Guid>>, IIdempotentCommand
{
    string IIdempotentCommand.IdempotencyKey => IdempotencyKey;
}

// Query の例(Transaction 非適用、Caching 適用可能)
public sealed record GetProductsQuery : ICacheableQuery<Result<IEnumerable<ProductDto>>>
{
    public string CacheKey => "Products:List:All";
    public TimeSpan CacheDuration => TimeSpan.FromMinutes(5);
}
```

### Read-Your-Own-Write パターン

```csharp
// Command Handler での読取り一貫性確保
public class CreateProductHandler : IRequestHandler<CreateProductCommand, Result<ProductDto>>
{
    private readonly IProductRepository _repository;
    private readonly IMapper _mapper;
    
    public async Task<Result<ProductDto>> Handle(CreateProductCommand cmd, CancellationToken ct)
    {
        // 1. ドメインロジック実行
        var product = Product.Create(cmd.Name, cmd.Price);
        await _repository.SaveAsync(product, ct);
        
        // 2. 同一トランザクション内で DTO を返す(Read-Your-Own-Write)
        var dto = _mapper.Map<ProductDto>(product);
        
        return Result.Success(dto);
        
        // UI 側は再読込不要(dto をそのまま使える)
    }
}
```

---

## 8.3.2 Authorization二重防御戦略 (v2.0新規追加)

### UI レベル + Application レベルの二重化

```csharp
// 1. Command レベルの認可(必須防御)
[Authorize(Policy = "ProductDeletePolicy")]
public sealed record DeleteProductCommand(Guid ProductId) : ICommand<Result>;

// 2. AuthorizationBehavior(全 Command/Query に適用)
public class AuthorizationBehavior<TRequest, TResponse> 
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly ICurrentUserService _currentUser;
    private readonly IAuthorizationService _authService;
    private readonly ILogger<AuthorizationBehavior<TRequest, TResponse>> _logger;
    
    public async Task<TResponse> Handle(
        TRequest request, 
        RequestHandlerDelegate<TResponse> next, 
        CancellationToken ct)
    {
        var authorizeAttributes = request.GetType()
            .GetCustomAttributes<AuthorizeAttribute>();
        
        if (!authorizeAttributes.Any())
        {
            return await next();
        }
        
        foreach (var attribute in authorizeAttributes)
        {
            if (!string.IsNullOrEmpty(attribute.Policy))
            {
                var authResult = await _authService.AuthorizeAsync(
                    _currentUser.User, 
                    null, 
                    attribute.Policy);
                
                if (!authResult.Succeeded)
                {
                    _logger.LogWarning(
                        "認可失敗: {UserId}, Policy: {Policy}, Command: {CommandName}",
                        _currentUser.UserId,
                        attribute.Policy,
                        typeof(TRequest).Name);
                    
                    throw new UnauthorizedAccessException($"Policy '{attribute.Policy}' を満たしていません");
                }
            }
            
            if (!string.IsNullOrEmpty(attribute.Roles))
            {
                var roles = attribute.Roles.Split(',');
                if (!roles.Any(role => _currentUser.IsInRole(role.Trim())))
                {
                    _logger.LogWarning(
                        "認可失敗: {UserId}, RequiredRoles: {Roles}, Command: {CommandName}",
                        _currentUser.UserId,
                        attribute.Roles,
                        typeof(TRequest).Name);
                    
                    throw new UnauthorizedAccessException($"ロール '{attribute.Roles}' が必要です");
                }
            }
        }
        
        return await next();
    }
}

// 3. UI レベルの制御(UX 向上)
@inject IAuthorizationService AuthService
@inject ICurrentUserService CurrentUser

@code {
    private bool CanDeleteProducts { get; set; }
    
    protected override async Task OnInitializedAsync()
    {
        // UI 表示制御用の認可チェック
        var authResult = await AuthService.AuthorizeAsync(
            CurrentUser.User, 
            null, 
            "ProductDeletePolicy");
        
        CanDeleteProducts = authResult.Succeeded;
        
        await Actions.LoadAsync();
    }
}

@if (CanDeleteProducts)
{
    <button class="btn btn-danger" @onclick="() => Actions.DeleteAsync(product.Id)">
        削除
    </button>
}
else
{
    <button class="btn btn-danger" disabled title="権限がありません">
        削除
    </button>
}

// 4. Policy 定義
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("ProductDeletePolicy", policy =>
    {
        policy.RequireRole("Admin", "ProductManager");
        // または
        policy.RequireClaim("Permission", "Product.Delete");
    });
    
    options.AddPolicy("ProductCreatePolicy", policy =>
    {
        policy.RequireAuthenticatedUser();
        policy.RequireClaim("Permission", "Product.Create");
    });
});
```

### 多層防御の流れ

```
User Action
    ↓
[1] UI レベル: ボタン非表示/無効化(UX 向上)
    ↓
[2] PageActions: 追加チェック(オプション)
    ↓
[3] AuthorizationBehavior: 必須チェック(セキュリティ境界)
    ↓
[4] Handler: ドメインルールチェック(ビジネスロジック)
    ↓
Success
```

# Blazor Architecture Guide v2.0 - Performance & Reliability Improvements

## 11.1.1 Outbox Dispatcher の信頼性向上 (v2.0改善)

### Outbox テーブル DDL

```sql
-- Outbox Messages テーブル
CREATE TABLE OutboxMessages (
    Id UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
    EventType NVARCHAR(500) NOT NULL,
    PayloadJson NVARCHAR(MAX) NOT NULL,
    CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    PublishedAt DATETIME2 NULL,
    
    -- 状態管理
    Status NVARCHAR(50) NOT NULL DEFAULT 'Pending',  -- Pending | Publishing | Published | Failed
    AttemptCount INT NOT NULL DEFAULT 0,
    NextAttemptAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    LastError NVARCHAR(MAX) NULL,
    
    -- インデックス
    INDEX IX_OutboxMessages_Status_NextAttemptAt (Status, NextAttemptAt),
    INDEX IX_OutboxMessages_CreatedAt (CreatedAt)
);

-- Dead Letter Messages テーブル
CREATE TABLE DeadLetterMessages (
    Id UNIQUEIDENTIFIER PRIMARY KEY,
    OriginalEventType NVARCHAR(500) NOT NULL,
    PayloadJson NVARCHAR(MAX) NOT NULL,
    FailureReason NVARCHAR(MAX) NOT NULL,
    FailedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    AttemptCount INT NOT NULL,
    OriginalCreatedAt DATETIME2 NOT NULL,
    
    INDEX IX_DeadLetterMessages_FailedAt (FailedAt)
);
```

### Outbox Dispatcher 実装

```csharp
/// <summary>
/// Outbox Dispatcher - 信頼性向上版
/// - 指数バックオフ
/// - Dead Letter 対応
/// - 状態遷移管理
/// </summary>
public class OutboxDispatcher : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<OutboxDispatcher> _logger;
    
    private const int MaxAttempts = 5;
    private const int BatchSize = 100;
    private const int PollingIntervalSeconds = 10;
    
    public OutboxDispatcher(
        IServiceScopeFactory scopeFactory,
        ILogger<OutboxDispatcher> logger)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
    }
    
    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        _logger.LogInformation("Outbox Dispatcher 開始");
        
        while (!ct.IsCancellationRequested)
        {
            try
            {
                await ProcessPendingMessagesAsync(ct);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Outbox Dispatcher でエラーが発生しました");
            }
            
            await Task.Delay(TimeSpan.FromSeconds(PollingIntervalSeconds), ct);
        }
        
        _logger.LogInformation("Outbox Dispatcher 停止");
    }
    
    private async Task ProcessPendingMessagesAsync(CancellationToken ct)
    {
        using var scope = _scopeFactory.CreateScope();
        var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        var eventBus = scope.ServiceProvider.GetRequiredService<IEventBus>();
        
        // Pending 状態で処理時刻が来ているメッセージを取得
        var pendingMessages = await dbContext.OutboxMessages
            .Where(m => m.Status == OutboxStatus.Pending && m.NextAttemptAt <= DateTime.UtcNow)
            .OrderBy(m => m.CreatedAt)
            .Take(BatchSize)
            .ToListAsync(ct);
        
        if (!pendingMessages.Any())
        {
            return;
        }
        
        _logger.LogInformation("処理対象メッセージ: {Count} 件", pendingMessages.Count);
        
        foreach (var message in pendingMessages)
        {
            await ProcessMessageAsync(message, dbContext, eventBus, ct);
        }
    }
    
    private async Task ProcessMessageAsync(
        OutboxMessage message, 
        AppDbContext dbContext,
        IEventBus eventBus,
        CancellationToken ct)
    {
        try
        {
            // 状態を Publishing に変更
            message.Status = OutboxStatus.Publishing;
            await dbContext.SaveChangesAsync(ct);
            
            _logger.LogDebug("メッセージ配信開始: {EventType}, Id: {MessageId}", 
                message.EventType, message.Id);
            
            // イベント配信
            await eventBus.PublishAsync(message.EventType, message.PayloadJson, ct);
            
            // 成功: Published 状態に変更
            message.Status = OutboxStatus.Published;
            message.PublishedAt = DateTime.UtcNow;
            await dbContext.SaveChangesAsync(ct);
            
            _logger.LogInformation("メッセージ配信完了: {EventType}, Id: {MessageId}", 
                message.EventType, message.Id);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "メッセージ配信失敗: {EventType}, Id: {MessageId}, Attempt: {AttemptCount}", 
                message.EventType, message.Id, message.AttemptCount + 1);
            
            // 失敗時の処理
            message.AttemptCount++;
            message.LastError = ex.ToString();
            
            if (message.AttemptCount >= MaxAttempts)
            {
                // 最大試行回数超過: Dead Letter へ移動
                await MoveToDeadLetterAsync(message, dbContext, ct);
                
                _logger.LogWarning("メッセージを Dead Letter へ移動: {EventType}, Id: {MessageId}", 
                    message.EventType, message.Id);
            }
            else
            {
                // リトライ: 指数バックオフで次回実行時刻を設定
                message.Status = OutboxStatus.Pending;
                message.NextAttemptAt = DateTime.UtcNow.AddMinutes(Math.Pow(2, message.AttemptCount));
                
                await dbContext.SaveChangesAsync(ct);
                
                _logger.LogInformation("メッセージをリトライ予約: {EventType}, Id: {MessageId}, NextAttempt: {NextAttemptAt}", 
                    message.EventType, message.Id, message.NextAttemptAt);
            }
        }
    }
    
    private async Task MoveToDeadLetterAsync(
        OutboxMessage message, 
        AppDbContext dbContext,
        CancellationToken ct)
    {
        // Dead Letter Message を作成
        var deadLetter = new DeadLetterMessage
        {
            Id = message.Id,
            OriginalEventType = message.EventType,
            PayloadJson = message.PayloadJson,
            FailureReason = message.LastError ?? "Unknown error",
            FailedAt = DateTime.UtcNow,
            AttemptCount = message.AttemptCount,
            OriginalCreatedAt = message.CreatedAt
        };
        
        dbContext.DeadLetterMessages.Add(deadLetter);
        
        // 元のメッセージを削除(または Failed 状態に変更)
        message.Status = OutboxStatus.Failed;
        
        await dbContext.SaveChangesAsync(ct);
    }
}

/// <summary>
/// Outbox Message エンティティ
/// </summary>
public class OutboxMessage
{
    public Guid Id { get; set; }
    public string EventType { get; set; } = string.Empty;
    public string PayloadJson { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public DateTime? PublishedAt { get; set; }
    
    public OutboxStatus Status { get; set; }
    public int AttemptCount { get; set; }
    public DateTime NextAttemptAt { get; set; }
    public string? LastError { get; set; }
}

/// <summary>
/// Outbox 状態
/// </summary>
public enum OutboxStatus
{
    Pending,
    Publishing,
    Published,
    Failed
}

/// <summary>
/// Dead Letter Message エンティティ
/// </summary>
public class DeadLetterMessage
{
    public Guid Id { get; set; }
    public string OriginalEventType { get; set; } = string.Empty;
    public string PayloadJson { get; set; } = string.Empty;
    public string FailureReason { get; set; } = string.Empty;
    public DateTime FailedAt { get; set; }
    public int AttemptCount { get; set; }
    public DateTime OriginalCreatedAt { get; set; }
}
```

### Dead Letter 再処理ツール

```csharp
/// <summary>
/// Dead Letter Messages の再処理ツール
/// </summary>
public class DeadLetterReprocessor
{
    private readonly AppDbContext _dbContext;
    private readonly IEventBus _eventBus;
    private readonly ILogger<DeadLetterReprocessor> _logger;
    
    public async Task<ReprocessResult> ReprocessAsync(Guid deadLetterId, CancellationToken ct = default)
    {
        var deadLetter = await _dbContext.DeadLetterMessages.FindAsync(new object[] { deadLetterId }, ct);
        if (deadLetter == null)
        {
            return ReprocessResult.NotFound;
        }
        
        try
        {
            // 再配信試行
            await _eventBus.PublishAsync(deadLetter.OriginalEventType, deadLetter.PayloadJson, ct);
            
            // 成功: Dead Letter から削除
            _dbContext.DeadLetterMessages.Remove(deadLetter);
            await _dbContext.SaveChangesAsync(ct);
            
            _logger.LogInformation("Dead Letter を再処理しました: {Id}", deadLetterId);
            
            return ReprocessResult.Success;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Dead Letter の再処理に失敗しました: {Id}", deadLetterId);
            return ReprocessResult.Failed;
        }
    }
    
    public async Task<IEnumerable<DeadLetterMessage>> GetDeadLettersAsync(
        int pageNumber = 1,
        int pageSize = 50,
        CancellationToken ct = default)
    {
        return await _dbContext.DeadLetterMessages
            .OrderByDescending(d => d.FailedAt)
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync(ct);
    }
}

public enum ReprocessResult
{
    Success,
    Failed,
    NotFound
}
```

---

## 12.1.1 Read最適化とキャッシュ戦略の強化 (v2.0改善)

### DTO と集約の粒度最適化

```csharp
// ✅ 画面専用 DTO(N+1 排除、過剰列排除)
public record ProductListItemDto(
    Guid Id,
    string Name,
    decimal Price,
    string Currency,
    int StockQuantity,
    string CategoryName,     // JOIN で取得
    int ReviewCount,         // 集計で取得
    decimal AverageRating    // 集計で取得
);

// ✅ Dapper による最適化クエリ
public class ProductReadDao : IProductReadDao
{
    private readonly IDbConnection _connection;
    
    public async Task<IEnumerable<ProductListItemDto>> GetListAsync(CancellationToken ct)
    {
        const string sql = @"
            SELECT 
                p.Id,
                p.Name,
                p.Price,
                p.Currency,
                p.StockQuantity,
                c.Name AS CategoryName,
                COUNT(DISTINCT r.Id) AS ReviewCount,
                ISNULL(AVG(CAST(r.Rating AS FLOAT)), 0) AS AverageRating
            FROM Products p
            INNER JOIN Categories c ON p.CategoryId = c.Id
            LEFT JOIN Reviews r ON p.Id = r.ProductId
            WHERE p.IsDeleted = 0
            GROUP BY 
                p.Id, p.Name, p.Price, p.Currency, p.StockQuantity, c.Name
            ORDER BY p.CreatedAt DESC";
        
        return await _connection.QueryAsync<ProductListItemDto>(
            sql, 
            cancellationToken: ct);
    }
    
    public async Task<ProductDetailDto?> GetDetailAsync(Guid productId, CancellationToken ct)
    {
        // マルチマッピングで関連データを一度に取得
        const string sql = @"
            SELECT 
                p.Id, p.Name, p.Description, p.Price, p.Currency, p.StockQuantity,
                c.Id, c.Name,
                i.Id, i.Url, i.AltText
            FROM Products p
            INNER JOIN Categories c ON p.CategoryId = c.Id
            LEFT JOIN ProductImages i ON p.Id = i.ProductId
            WHERE p.Id = @ProductId AND p.IsDeleted = 0";
        
        var productDictionary = new Dictionary<Guid, ProductDetailDto>();
        
        await _connection.QueryAsync<ProductDetailDto, CategoryDto, ProductImageDto, ProductDetailDto>(
            sql,
            (product, category, image) =>
            {
                if (!productDictionary.TryGetValue(product.Id, out var productEntry))
                {
                    productEntry = product;
                    productEntry.Category = category;
                    productEntry.Images = new List<ProductImageDto>();
                    productDictionary.Add(product.Id, productEntry);
                }
                
                if (image != null)
                {
                    productEntry.Images.Add(image);
                }
                
                return productEntry;
            },
            new { ProductId = productId },
            splitOn: "Id,Id");
        
        return productDictionary.Values.FirstOrDefault();
    }
}

// ❌ アンチパターン: N+1 問題
public async Task<IEnumerable<ProductListItemDto>> GetListAsync_Bad(CancellationToken ct)
{
    var products = await _dbContext.Products
        .Where(p => !p.IsDeleted)
        .ToListAsync(ct);
    
    var dtos = new List<ProductListItemDto>();
    
    foreach (var product in products)  // N+1 問題
    {
        var category = await _dbContext.Categories.FindAsync(product.CategoryId);  // +1
        var reviewCount = await _dbContext.Reviews.CountAsync(r => r.ProductId == product.Id);  // +1
        
        dtos.Add(new ProductListItemDto(
            product.Id,
            product.Name,
            product.Price,
            product.Currency,
            product.StockQuantity,
            category.Name,
            reviewCount,
            0));
    }
    
    return dtos;
}
```

### 複雑な一覧画面: DB ビュー + Dapper

```sql
-- Materialized View(定期更新)
CREATE VIEW ProductListView AS
SELECT 
    p.Id,
    p.Name,
    p.Price,
    p.Currency,
    p.StockQuantity,
    p.CreatedAt,
    c.Name AS CategoryName,
    COUNT(DISTINCT r.Id) AS ReviewCount,
    ISNULL(AVG(CAST(r.Rating AS FLOAT)), 0) AS AverageRating,
    COUNT(DISTINCT o.Id) AS OrderCount,
    SUM(oi.Quantity) AS TotalSold
FROM Products p
INNER JOIN Categories c ON p.CategoryId = c.Id
LEFT JOIN Reviews r ON p.Id = r.ProductId
LEFT JOIN OrderItems oi ON p.Id = oi.ProductId
LEFT JOIN Orders o ON oi.OrderId = o.Id
WHERE p.IsDeleted = 0
GROUP BY 
    p.Id, p.Name, p.Price, p.Currency, p.StockQuantity, p.CreatedAt, c.Name;

-- インデックス
CREATE INDEX IX_ProductListView_CategoryName ON ProductListView(CategoryName);
CREATE INDEX IX_ProductListView_CreatedAt ON ProductListView(CreatedAt DESC);
```

```csharp
// Dapper で View を読む
public class ProductReadDao : IProductReadDao
{
    public async Task<IEnumerable<ProductListItemDto>> GetListFromViewAsync(
        string? categoryFilter = null,
        int pageNumber = 1,
        int pageSize = 50,
        CancellationToken ct = default)
    {
        var sql = @"
            SELECT * FROM ProductListView
            WHERE (@CategoryFilter IS NULL OR CategoryName = @CategoryFilter)
            ORDER BY CreatedAt DESC
            OFFSET @Offset ROWS FETCH NEXT @PageSize ROWS ONLY";
        
        return await _connection.QueryAsync<ProductListItemDto>(
            sql,
            new 
            { 
                CategoryFilter = categoryFilter,
                Offset = (pageNumber - 1) * pageSize,
                PageSize = pageSize
            },
            cancellationToken: ct);
    }
}
```

### キャッシュキー規約と無効化戦略

```csharp
/// <summary>
/// キャッシュキー規約
/// パターン: {Feature}:{Entity}:{TenantId}:{UserId}:{Parameters}
/// </summary>
public static class CacheKeys
{
    public static string ProductList(string tenantId, string? filter = null) =>
        $"Products:List:{tenantId}:{filter ?? "all"}";
    
    public static string ProductDetail(Guid productId, string tenantId) =>
        $"Products:Detail:{tenantId}:{productId}";
    
    public static string ProductsByCategory(string categoryName, string tenantId) =>
        $"Products:ByCategory:{tenantId}:{categoryName}";
    
    // ワイルドカード用パターン
    public static string ProductsPattern(string tenantId) =>
        $"Products:*:{tenantId}:*";
}

/// <summary>
/// Caching Behavior(Query 専用)
/// </summary>
public class CachingBehavior<TRequest, TResponse> 
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : ICacheableQuery<TResponse>
{
    private readonly IDistributedCache _cache;
    private readonly ILogger<CachingBehavior<TRequest, TResponse>> _logger;
    
    public async Task<TResponse> Handle(
        TRequest request, 
        RequestHandlerDelegate<TResponse> next, 
        CancellationToken ct)
    {
        var cacheKey = request.CacheKey;
        
        // キャッシュから取得
        var cachedResponse = await _cache.GetStringAsync(cacheKey, ct);
        if (cachedResponse != null)
        {
            _logger.LogDebug("キャッシュヒット: {CacheKey}", cacheKey);
            return JsonSerializer.Deserialize<TResponse>(cachedResponse)!;
        }
        
        _logger.LogDebug("キャッシュミス: {CacheKey}", cacheKey);
        
        // 実行
        var response = await next();
        
        // キャッシュに保存
        var serialized = JsonSerializer.Serialize(response);
        var options = new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = request.CacheDuration
        };
        
        await _cache.SetStringAsync(cacheKey, serialized, options, ct);
        
        _logger.LogDebug("キャッシュ保存: {CacheKey}, Duration: {Duration}", 
            cacheKey, request.CacheDuration);
        
        return response;
    }
}

/// <summary>
/// Cache Invalidation Service
/// </summary>
public class CacheInvalidationService : ICacheInvalidationService
{
    private readonly IDistributedCache _cache;
    private readonly ILogger<CacheInvalidationService> _logger;
    
    /// <summary>
    /// 特定キーを無効化
    /// </summary>
    public async Task InvalidateAsync(string cacheKey, CancellationToken ct = default)
    {
        await _cache.RemoveAsync(cacheKey, ct);
        _logger.LogInformation("キャッシュ無効化: {CacheKey}", cacheKey);
    }
    
    /// <summary>
    /// パターンマッチで複数キーを無効化
    /// </summary>
    public async Task InvalidatePatternAsync(string pattern, CancellationToken ct = default)
    {
        // Redis の場合: KEYS コマンドでパターンマッチ
        // 注意: 本番環境では SCAN を使用すること
        
        _logger.LogInformation("キャッシュパターン無効化: {Pattern}", pattern);
        
        // 実装は使用するキャッシュプロバイダに依存
        // Redis: SCAN + DEL
        // SQL Server: キーテーブルから検索して削除
    }
}
```

### SignalR によるキャッシュ無効化

```csharp
/// <summary>
/// Product Hub - リアルタイム通知とキャッシュ無効化
/// </summary>
public class ProductHub : Hub
{
    private readonly ICacheInvalidationService _cacheInvalidation;
    private readonly ILogger<ProductHub> _logger;
    
    public async Task NotifyProductChanged(Guid productId, string action, string tenantId)
    {
        // 1. 該当キャッシュを無効化
        await _cacheInvalidation.InvalidateAsync(
            CacheKeys.ProductDetail(productId, tenantId));
        
        // 2. リスト系キャッシュも無効化
        await _cacheInvalidation.InvalidatePatternAsync(
            CacheKeys.ProductsPattern(tenantId));
        
        // 3. 全クライアントに通知
        await Clients.All.SendAsync("ProductChanged", new
        {
            ProductId = productId,
            Action = action,
            TenantId = tenantId,
            Timestamp = DateTime.UtcNow
        });
        
        _logger.LogInformation("商品変更通知: {ProductId}, Action: {Action}", productId, action);
    }
}

/// <summary>
/// Store での受信と無効化
/// </summary>
public class ProductsStore : IDisposable
{
    private HubConnection? _hubConnection;
    
    protected override async Task OnInitializedAsync()
    {
        // SignalR 接続
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(_navigationManager.ToAbsoluteUri("/hubs/products"))
            .WithAutomaticReconnect()
            .Build();
        
        // イベント受信
        _hubConnection.On<ProductChangedNotification>("ProductChanged", async notification =>
        {
            if (IsRelevantToCurrentState(notification))
            {
                _logger.LogInformation("商品変更通知受信: {ProductId}", notification.ProductId);
                
                // 再読み込み
                await LoadAsync();
            }
        });
        
        await _hubConnection.StartAsync();
    }
    
    private bool IsRelevantToCurrentState(ProductChangedNotification notification)
    {
        // 現在表示中の商品に関連するかチェック
        return _state.Products.Any(p => p.Id == notification.ProductId);
    }
    
    public void Dispose()
    {
        _hubConnection?.DisposeAsync().AsTask().Wait();
    }
}
```

