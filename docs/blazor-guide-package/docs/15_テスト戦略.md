# 15. テスト戦略

[← 目次に戻る](00_README.md)

---

## 15. テスト戦略

### 13.1 テストピラミッド

```
        ┌─────────────┐
        │  E2E Tests  │  ← 少数の重要な統合シナリオのみ
        │   (5-10%)   │
        ├─────────────┤
        │ Integration │  ← パイプライン全体とDB連携のテスト
        │    Tests    │
        │   (30%)     │
        ├─────────────┤
        │    Unit     │  ← Domain、Handler、Actionsの単体テスト
        │    Tests    │
        │   (60%)     │
        └─────────────┘
```

### 13.2 Unit Tests

#### **Domain層のテスト**

```csharp
public class ProductTests
{
    [Fact]
    public void Delete_在庫あり_例外()
    {
        // Arrange
        var product = Product.Create(
            ProductId.New(),
            "テスト商品",
            "説明",
            new Money(1000),
            initialStock: 10);
        
        // Act & Assert
        var ex = Assert.Throws<DomainException>(() => product.Delete());
        Assert.Equal("在庫がある商品は削除できません", ex.Message);
    }
    
    [Fact]
    public void ChangeName_空文字_例外()
    {
        // Arrange
        var product = Product.Create(...);
        
        // Act & Assert
        Assert.Throws<DomainException>(() => product.ChangeName(""));
    }
    
    [Fact]
    public void ChangePrice_50%以上の値下げ_公開中は例外()
    {
        // Arrange
        var product = Product.Create(..., price: new Money(1000), ...);
        product.Publish();
        
        // Act & Assert
        var ex = Assert.Throws<DomainException>(() => 
            product.ChangePrice(new Money(400)));
        
        Assert.Contains("50%以上の値下げ", ex.Message);
    }
}
```

#### **Handler層のテスト**

```csharp
public class DeleteProductHandlerTests
{
    [Fact]
    public async Task Handle_商品が存在する_削除成功()
    {
        // Arrange
        var productId = ProductId.New();
        var product = Product.Create(productId, "商品", "説明", new Money(1000), 0);
        
        var repoMock = new Mock<IProductRepository>();
        repoMock.Setup(r => r.GetAsync(productId, It.IsAny<CancellationToken>()))
            .ReturnsAsync(product);
        
        var handler = new DeleteProductHandler(repoMock.Object, Mock.Of<ILogger<DeleteProductHandler>>());
        var command = new DeleteProductCommand(productId.Value);
        
        // Act
        var result = await handler.Handle(command, CancellationToken.None);
        
        // Assert
        Assert.True(result.IsSuccess);
        repoMock.Verify(r => r.SaveAsync(product, It.IsAny<CancellationToken>()), Times.Once);
    }
    
    [Fact]
    public async Task Handle_商品が存在しない_失敗()
    {
        // Arrange
        var repoMock = new Mock<IProductRepository>();
        repoMock.Setup(r => r.GetAsync(It.IsAny<ProductId>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((Product?)null);
        
        var handler = new DeleteProductHandler(repoMock.Object, Mock.Of<ILogger<DeleteProductHandler>>());
        var command = new DeleteProductCommand(Guid.NewGuid());
        
        // Act
        var result = await handler.Handle(command, CancellationToken.None);
        
        // Assert
        Assert.False(result.IsSuccess);
        Assert.Equal("商品が見つかりません", result.Error);
    }
}
```

#### **PageActionsのテスト**

```csharp
public class ProductListActionsTests
{
    [Fact]
    public async Task DeleteAsync_ユーザーがキャンセル_Storeを呼ばない()
    {
        // Arrange
        var storeMock = new Mock<ProductsStore>(MockBehavior.Strict);
        var confirmMock = new Mock<IConfirmDialog>();
        confirmMock.Setup(x => x.ShowAsync(
            It.IsAny<string>(),
            It.IsAny<string>(),
            It.IsAny<string>(),
            It.IsAny<string>()))
            .ReturnsAsync(false);  // キャンセル
        
        var actions = new ProductListActions(
            storeMock.Object,
            confirmMock.Object,
            Mock.Of<IToast>(),
            Mock.Of<NavigationManager>(),
            Mock.Of<ILogger<ProductListActions>>());
        
        // Act
        await actions.DeleteAsync(Guid.NewGuid());
        
        // Assert
        storeMock.Verify(
            x => x.DeleteAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()),
            Times.Never);
    }
}
```

### 13.3 Integration Tests

```csharp
public class DeleteProductIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly WebApplicationFactory<Program> _factory;
    
    public DeleteProductIntegrationTests(WebApplicationFactory<Program> factory)
    {
        _factory = factory;
    }
    
    [Fact]
    public async Task DeleteProduct_エンドツーエンド_成功()
    {
        // Arrange
        using var scope = _factory.Services.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        
        var product = Product.Create(
            ProductId.New(),
            "テスト商品",
            "説明",
            new Money(1000),
            0);
        
        context.Products.Add(product);
        await context.SaveChangesAsync();
        
        var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
        var command = new DeleteProductCommand(product.Id.Value);
        
        // Act
        var result = await mediator.Send(command);
        
        // Assert
        Assert.True(result.IsSuccess);
        
        var deletedProduct = await context.Products.FindAsync(product.Id);
        Assert.Null(deletedProduct);
    }
}
```

### 13.4 E2E Tests (bUnit)

```csharp
public class ProductListComponentTests : TestContext
{
    [Fact]
    public void ProductList_初期表示_ローディング表示()
    {
        // Arrange
        var storeMock = new Mock<ProductsStore>();
        storeMock.Setup(s => s.GetState())
            .Returns(new ProductsState { IsLoading = true });
        
        Services.AddSingleton(storeMock.Object);
        Services.AddSingleton(Mock.Of<ProductListActions>());
        
        // Act
        var cut = RenderComponent<ProductList>();
        
        // Assert
        cut.Find(".loading-indicator").Should().NotBeNull();
    }
    
    [Fact]
    public void ProductList_削除ボタンクリック_Actionsを呼ぶ()
    {
        // Arrange
        var productId = Guid.NewGuid();
        var actionsMock = new Mock<ProductListActions>();
        
        var storeMock = new Mock<ProductsStore>();
        storeMock.Setup(s => s.GetState())
            .Returns(new ProductsState
            {
                Products = ImmutableList.Create(
                    new ProductDto(productId, "商品", 1000, "JPY", 10, "Published", 1))
            });
        
        Services.AddSingleton(storeMock.Object);
        Services.AddSingleton(actionsMock.Object);
        
        // Act
        var cut = RenderComponent<ProductList>();
        cut.Find(".btn-danger").Click();
        
        // Assert
        actionsMock.Verify(a => a.DeleteAsync(productId, It.IsAny<CancellationToken>()), Times.Once);
    }
}
```

---

### 13.4 E2Eテストのベストプラクティス（Playwright）

#### 13.4.1 テストデータベースの設定

**重要:** E2Eテストでは**InMemoryDatabase**を使用しますが、複数のDbContextがある場合は注意が必要です。

```csharp
// ❌ 間違い: 異なるDbContextを使用
protected async Task<Guid> CreateTestProductAsync(...)
{
    // AppDbContextにデータを作成
    var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
    await context.Products.AddAsync(product);
    await context.SaveChangesAsync();
}

public class TestProductReadRepository
{
    // ProductCatalogDbContextから読み取り
    private readonly ProductCatalogDbContext _context;
    // ↑ 別のInMemoryDBインスタンス！データが見つからない
}
```

**何が起きるか:**
- `AppDbContext`と`ProductCatalogDbContext`は**別々のInMemoryデータベース**
- テストでデータを作成しても、リポジトリから見つからない
- "商品が見つかりません"エラー → タイムアウト

**修正:**
```csharp
// ✅ 正しい: 同じDbContextを使用
protected async Task<Guid> CreateTestProductAsync(...)
{
    // ProductCatalogDbContextを使用（Repositoryと同じ）
    var context = scope.ServiceProvider.GetRequiredService<ProductCatalogDbContext>();
    await context.Products.AddAsync(product);
    await context.SaveChangesAsync();
}
```

---

#### 13.4.2 EF Core IncludeとOwnsMany関係

**問題:**
EF Coreで`OwnsMany`関係を使う場合、publicプロパティを`Ignore`設定することがあります。
この場合、`.Include()`でそのプロパティを参照するとエラーになります。

```csharp
// EF Core設定
public class ProductConfiguration : IEntityTypeConfiguration<Product>
{
    public void Configure(EntityTypeBuilder<Product> builder)
    {
        builder.Ignore(p => p.Images);  // ← publicプロパティは無視
        builder.OwnsMany<ProductImage>("_images", ...);  // ← privateフィールドを使用
    }
}

// ❌ テストリポジトリ: Ignoreされたプロパティを参照
var products = await _context.Products.Include(p => p.Images).ToListAsync();
// エラー: "The expression 'p.Images' is invalid inside an 'Include' operation"
```

**修正:**
```csharp
// ✅ OwnsMany関係は自動的にロードされるため、Includeは不要
var products = await _context.Products.ToListAsync();
```

---

#### 13.4.3 Blazor Serverライフサイクルとready信号

**問題:**
Blazor ServerのPrerenderingにより、`OnInitializedAsync`内でJavaScript interopを呼ぶとエラーになります。
E2Eテストで使用する`ready`信号も影響を受けます。

```csharp
// ❌ 間違い: OnInitializedAsyncでJSを呼ぶ
protected override async Task OnInitializedAsync()
{
    await Actions.LoadAsync(ProductId);
    await JS.InvokeVoidAsync("window.__e2e.setReady", $"product:{ProductId}");
    // エラー: "JavaScript interop calls cannot be issued at this time"
}
```

**修正:**
```csharp
// ✅ 正しい: OnAfterRenderAsyncでJSを呼ぶ
private bool _readySignaled;

protected override async Task OnInitializedAsync()
{
    Store.OnChangeAsync += HandleStateChanged;
    await Actions.LoadAsync(ProductId);
}

private async Task HandleStateChanged()
{
    await InvokeAsync(StateHasChanged);
}

protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (!_readySignaled && State.Product != null)
    {
        _readySignaled = true;
        try
        {
            await JS.InvokeVoidAsync("window.__e2e.setReady", $"product:{ProductId}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[E2E] setReady failed: {ex.Message}");
        }
    }
}

public void Dispose()
{
    Store.OnChangeAsync -= HandleStateChanged;
}
```

**ポイント:**
- `OnAfterRenderAsync`はクライアント側レンダリング後に実行される
- `!_readySignaled`で複数回実行を防止
- `State.Product != null`でデータ到着を確認

---

#### 13.4.4 デュアル待機戦略（Ready信号 or DOMセレクタ）

```csharp
protected async Task WaitForReadyOrSelectorAsync(string key, string selector, int timeoutMs = 30000)
{
    var readyTask = WaitForReadyAsync(key, timeoutMs);
    var selectorTask = Page!.WaitForSelectorAsync(selector, new() { Timeout = timeoutMs, State = WaitForSelectorState.Visible });

    var completedTask = await Task.WhenAny(readyTask, selectorTask);

    if (completedTask == readyTask)
    {
        Console.WriteLine($"[E2E] Ready flag '{key}' signaled");
        return;
    }
    else if (completedTask == selectorTask)
    {
        Console.WriteLine($"[E2E] Selector '{selector}' found");
        return;
    }

    throw new TimeoutException($"Both ready flag '{key}' and selector '{selector}' timed out");
}
```

**メリット:**
- ready信号が失敗してもDOMセレクタで検出できる
- どちらか先に完了したら成功
- タイムアウト時間を統一

---

#### 13.4.5 ブラウザコンソールログ収集

```csharp
protected override async Task InitializeAsync()
{
    // ブラウザコンソールログを収集
    Page.Console += (_, msg) =>
    {
        var msgType = msg.Type;
        var msgText = msg.Text;
        Console.WriteLine($"[BROWSER {msgType}] {msgText}");
    };

    await base.InitializeAsync();
}
```

**メリット:**
- JavaScript エラーをテスト出力に表示
- Prerender エラーを検出できる
- デバッグが容易

---

#### 13.4.6 失敗時のスクリーンショット保存

```csharp
public async Task<PlaywrightTestBase> ExecuteTestAsync(Func<Task> testAction, [CallerMemberName] string testName = "")
{
    try
    {
        await testAction();
    }
    catch
    {
        await SaveScreenshotOnFailureAsync(testName);
        throw;
    }
    return this;
}

private async Task SaveScreenshotOnFailureAsync(string testName)
{
    if (Page == null) return;
    try
    {
        var timestamp = DateTime.Now.ToString("yyyyMMdd-HHmmss");
        var screenshotPath = Path.Combine("screenshots", $"{testName}-{timestamp}.png");
        Directory.CreateDirectory("screenshots");
        await Page.ScreenshotAsync(new PageScreenshotOptions { Path = screenshotPath });
        Console.WriteLine($"[E2E] Screenshot saved: {screenshotPath}");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[E2E] Failed to save screenshot: {ex.Message}");
    }
}
```

---

#### 13.4.7 E2Eテストのまとめ

**よくある3つの落とし穴と解決策:**

1. **DbContextの不一致**
   - 問題: テストデータ作成とリポジトリで異なるDbContextを使用
   - 解決: 同じDbContextを使用する

2. **EF Core Includeエラー**
   - 問題: `Ignore`されたプロパティを`.Include()`で参照
   - 解決: `OwnsMany`関係は自動ロードされるため`.Include()`不要

3. **Blazor Prerenderingエラー**
   - 問題: `OnInitializedAsync`でJavaScript interopを呼ぶ
   - 解決: `OnAfterRenderAsync`に移動し、`firstRender`と`State != null`でガード

**ベストプラクティス:**
- ✅ デュアル待機戦略（ready信号 or DOMセレクタ）
- ✅ ブラウザコンソールログ収集
- ✅ 失敗時のスクリーンショット保存
- ✅ 適切なタイムアウト設定（30秒推奨）
- ✅ 詳細なログ出力（Store/Handler/Repository）

---

