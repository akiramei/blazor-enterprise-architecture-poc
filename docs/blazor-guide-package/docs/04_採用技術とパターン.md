# 4. 採用技術とパターン

[← 目次に戻る](00_README.md)

---

## 4. 採用技術とパターン

### 4.1 コア技術スタック

| 技術 | 用途 | 必須/推奨 |
|------|------|----------|
| **.NET 8+** | フレームワーク | 必須 |
| **Blazor Server / WASM** | UIフレームワーク | 必須 |
| **MediatR** | CQRS/Mediatorパターン | 必須 |
| **Entity Framework Core** | ORM(書き込み用) | 推奨 |
| **FluentValidation** | バリデーション | 推奨 |
| **SignalR** | リアルタイム通信 | 推奨 |
| **Dapper** | 軽量DBアクセス(読み取り最適化) | オプション |

### 4.2 採用パターン一覧

#### **UI層のパターン**

##### **1. PageActions パターン**

```csharp
// 役割: UI手順のオーケストレーション(I/Oは行わない)
public sealed class ProductListActions
{
    private readonly ProductsStore _store;
    private readonly IConfirmDialog _confirm;
    private readonly IToast _toast;
    
    public async Task DeleteAsync(Guid id, CancellationToken ct = default)
    {
        // 1. 確認ダイアログ
        if (!await _confirm.ShowAsync("削除しますか?")) return;
        
        // 2. I/OはStoreに委譲
        var success = await _store.DeleteAsync(id, ct);
        
        // 3. 結果に応じた通知
        if (success) _toast.Success("削除しました");
        else _toast.Error("削除に失敗しました");
    }
}
```

**メリット:**
- I/Oとオーケストレーションの分離
- モックなしでテスト可能
- 手順の可視化

##### **2. Smart/Dumb パターン**

```csharp
// Smart Component: 状態管理とイベントハンドリング
@inject ProductsStore Store
@inject ProductListActions Actions

@foreach (var product in State.Products)
{
    <ProductCard Product="product" OnDelete="Actions.DeleteAsync" />
}

// Dumb Component: 純粋な表示とイベント発火
<div class="product-card">
    <h3>@Product.Name</h3>
    <button @onclick="() => OnDelete.InvokeAsync(Product.Id)">削除</button>
</div>

@code {
    [Parameter, EditorRequired] public ProductDto Product { get; set; }
    [Parameter] public EventCallback<Guid> OnDelete { get; set; }
}
```

**メリット:**
- Dumbコンポーネントの再利用性
- テストが容易
- 責務の明確化

##### **3. Store パターン(Flux/Redux風)**

```csharp
public sealed class ProductsStore : IDisposable
{
    private ProductsState _state = ProductsState.Empty;
    public event Func<Task>? OnChangeAsync;
    
    public ProductsState GetState() => _state;
    
    private void SetState(ProductsState newState)
    {
        _state = newState;
        OnChangeAsync?.Invoke();  // 購読者に通知
    }
}
```

**メリット:**
- 単一の状態ソース
- 予測可能な状態変更
- Time-travel debugging可能

#### **Application層のパターン**

##### **4. Mediator パターン(MediatR)**

```csharp
// リクエスト定義
public record DeleteProductCommand(Guid Id) : IRequest<Result>;

// ハンドラー
public class DeleteProductHandler : IRequestHandler<DeleteProductCommand, Result>
{
    public async Task<Result> Handle(DeleteProductCommand cmd, CancellationToken ct)
    {
        // ビジネスロジック
    }
}

// 呼び出し側
var result = await _mediator.Send(new DeleteProductCommand(id), ct);
```

**メリット:**
- 疎結合
- パイプラインの適用
- テストが容易

##### **5. Pipeline パターン(Behaviors)**

```csharp
// 横断的関心事を順序制御
services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
services.AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
services.AddTransient(typeof(IPipelineBehavior<,>), typeof(AuthorizationBehavior<,>));
services.AddTransient(typeof(IPipelineBehavior<,>), typeof(TransactionBehavior<,>));

// 実行順序: Logging → Validation → Authorization → Transaction → Handler
```

**メリット:**
- DRY(重複排除)
- 一貫した制御
- 拡張が容易

##### **6. CQRS パターン**

```csharp
// Query: 読み取り専用
public record GetProductsQuery : IQuery<Result<IEnumerable<ProductDto>>>;

public class GetProductsHandler : IRequestHandler<GetProductsQuery, Result<IEnumerable<ProductDto>>>
{
    private readonly IProductReadDao _dao;  // 読み取り最適化
    
    public async Task<Result<IEnumerable<ProductDto>>> Handle(GetProductsQuery query, CancellationToken ct)
    {
        var products = await _dao.GetProductListAsync(ct);
        return Result.Success(products);
    }
}

// Command: 書き込み
public record DeleteProductCommand(Guid Id) : ICommand<Result>;

public class DeleteProductHandler : IRequestHandler<DeleteProductCommand, Result>
{
    private readonly IProductRepository _repo;  // 集約操作
    
    public async Task<Result> Handle(DeleteProductCommand cmd, CancellationToken ct)
    {
        var product = await _repo.GetAsync(new ProductId(cmd.Id), ct);
        product.Delete();  // ドメインロジック
        await _repo.SaveAsync(product, ct);
        return Result.Success();
    }
}
```

#### **Domain層のパターン**

##### **7. Aggregate パターン(DDD)**

```csharp
public sealed class Product  // 集約ルート
{
    private ProductId _id;
    private string _name;
    private Money _price;
    private readonly List<ProductImage> _images = new();  // 集約内エンティティ
    
    // ビジネス不変条件を保護
    public void ChangeName(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new DomainException("商品名は必須です");
        
        _name = name;
        RaiseDomainEvent(new ProductNameChangedEvent(_id, name));
    }
    
    public void Delete()
    {
        if (_stock > 0)
            throw new DomainException("在庫がある商品は削除できません");
        
        RaiseDomainEvent(new ProductDeletedEvent(_id));
    }
}
```

**メリット:**
- ビジネスルールの集約
- 不変条件の保護
- トランザクション境界が明確

##### **8. Domain Event パターン**

```csharp
public abstract record DomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTime OccurredAt { get; } = DateTime.UtcNow;
}

public record ProductDeletedEvent(ProductId ProductId) : DomainEvent;

// 集約がイベントを発行
public abstract class AggregateRoot
{
    private readonly List<DomainEvent> _domainEvents = new();
    
    protected void RaiseDomainEvent(DomainEvent @event)
    {
        _domainEvents.Add(@event);
    }
    
    public IReadOnlyList<DomainEvent> GetDomainEvents() => _domainEvents;
}
```

#### **Infrastructure層のパターン**

##### **9. Repository パターン**

```csharp
public interface IProductRepository
{
    Task<Product?> GetAsync(ProductId id, CancellationToken ct = default);
    Task SaveAsync(Product product, CancellationToken ct = default);
}

public class EfProductRepository : IProductRepository
{
    private readonly AppDbContext _context;
    
    public async Task<Product?> GetAsync(ProductId id, CancellationToken ct)
    {
        return await _context.Products
            .Include(p => p.Images)  // 集約全体を取得
            .FirstOrDefaultAsync(p => p.Id == id, ct);
    }
}
```

##### **10. Unit of Work パターン**

```csharp
// TransactionBehaviorで自動管理
public class TransactionBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : ICommand<TResponse>
{
    private readonly IUnitOfWork _unitOfWork;
    
    public async Task<TResponse> Handle(...)
    {
        await _unitOfWork.BeginTransactionAsync(ct);
        
        try
        {
            var response = await next();
            
            if (response.IsSuccess)
                await _unitOfWork.CommitAsync(ct);
            else
                await _unitOfWork.RollbackAsync(ct);
            
            return response;
        }
        catch
        {
            await _unitOfWork.RollbackAsync(ct);
            throw;
        }
    }
}
```

##### **11. Outbox パターン**

```csharp
// トランザクション内で統合イベントを記録
public class OutboxMessage
{
    public Guid Id { get; set; }
    public string EventType { get; set; }
    public string PayloadJson { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? PublishedAt { get; set; }
}

// バックグラウンドジョブで配信
public class OutboxDispatcher : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            var messages = await _repository.GetUnpublishedAsync();
            
            foreach (var message in messages)
            {
                await _eventBus.PublishAsync(message);
                await _repository.MarkAsPublishedAsync(message.Id);
            }
            
            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
        }
    }
}
```

### 4.3 信頼性パターン

##### **12. Idempotency パターン**

```csharp
public abstract record CommandBase : IRequest<Result>
{
    public string IdempotencyKey { get; init; } = Guid.NewGuid().ToString();
}

public class IdempotencyBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
{
    public async Task<TResponse> Handle(...)
    {
        var existing = await _store.GetAsync(request.IdempotencyKey);
        if (existing != null)
            return existing.GetResult<TResponse>();  // 既存結果を返す
        
        var response = await next();
        await _store.SaveAsync(request.IdempotencyKey, response);
        return response;
    }
}
```

##### **13. Inbox パターン**

```csharp
public class ProductDeletedEventHandler : INotificationHandler<ProductDeletedIntegrationEvent>
{
    public async Task Handle(ProductDeletedIntegrationEvent evt, CancellationToken ct)
    {
        // 重複チェック
        if (await _inboxStore.IsProcessedAsync(evt.EventId, ct))
            return;
        
        // ビジネスロジック実行
        await ProcessEventAsync(evt, ct);
        
        // 処理済みマーク
        await _inboxStore.MarkAsProcessedAsync(evt.EventId, ct);
    }
}
```

##### **14. SAGA パターン**

```csharp
public class OrderProcessSaga
{
    public async Task ExecuteAsync(Guid orderId)
    {
        try
        {
            // Step 1: 在庫引当
            var reserveResult = await ReserveInventoryAsync(orderId);
            
            // Step 2: 決済処理
            var paymentResult = await ProcessPaymentAsync(orderId);
            
            // Step 3: 配送手配
            var shippingResult = await ArrangeShippingAsync(orderId);
        }
        catch (Exception)
        {
            // 補償処理(ロールバック)
            await CompensateAsync(orderId);
            throw;
        }
    }
}
```

---
