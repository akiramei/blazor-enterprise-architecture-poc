# 11. 信頼性パターン

[← 目次に戻る](00_README.md)

---

## 11. 信頼性パターン

### 11.1 Idempotency(冪等性)の完全実装

#### **データベーススキーマ**

```sql
CREATE TABLE IdempotencyRecords (
    IdempotencyKey NVARCHAR(255) PRIMARY KEY,
    CommandType NVARCHAR(200) NOT NULL,
    ResultJson NVARCHAR(MAX) NOT NULL,
    ProcessedAt DATETIME2 NOT NULL,
    ExpiresAt DATETIME2 NOT NULL,
    INDEX IX_ExpiresAt (ExpiresAt)
);
```

#### **実装の全体像**

前述のIdempotencyBehaviorに加えて、以下のクリーンアップジョブを実装:

```csharp
/// <summary>
/// 期限切れIdempotencyレコードのクリーンアップ
/// </summary>
public sealed class IdempotencyCleanupJob : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<IdempotencyCleanupJob> _logger;
    private readonly TimeSpan _interval = TimeSpan.FromHours(6);
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("IdempotencyCleanupJob started");
        
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await CleanupExpiredRecordsAsync(stoppingToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in IdempotencyCleanupJob");
            }
            
            await Task.Delay(_interval, stoppingToken);
        }
    }
    
    private async Task CleanupExpiredRecordsAsync(CancellationToken ct)
    {
        using var scope = _scopeFactory.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        
        var expiredRecords = await context.IdempotencyRecords
            .Where(r => r.ExpiresAt < DateTime.UtcNow)
            .ToListAsync(ct);
        
        if (expiredRecords.Any())
        {
            context.IdempotencyRecords.RemoveRange(expiredRecords);
            await context.SaveChangesAsync(ct);
            
            _logger.LogInformation(
                "Cleaned up {Count} expired idempotency records",
                expiredRecords.Count);
        }
    }
}
```

### 11.2 Inbox Pattern(受信側の重複排除)

#### **データベーススキーマ**

```sql
CREATE TABLE InboxMessages (
    MessageId NVARCHAR(255) PRIMARY KEY,
    MessageType NVARCHAR(200) NOT NULL,
    PayloadJson NVARCHAR(MAX) NOT NULL,
    ReceivedAt DATETIME2 NOT NULL,
    ProcessedAt DATETIME2 NULL,
    Status INT NOT NULL, -- 0:Pending, 1:Processed, 2:Failed
    ErrorMessage NVARCHAR(MAX) NULL,
    INDEX IX_Status_ReceivedAt (Status, ReceivedAt)
);
```

#### **完全実装**

```csharp
/// <summary>
/// Inbox統合イベントハンドラー基底クラス
/// </summary>
public abstract class InboxEventHandler<TEvent> : INotificationHandler<TEvent>
    where TEvent : IntegrationEvent
{
    private readonly IInboxStore _inboxStore;
    private readonly ILogger _logger;
    
    protected InboxEventHandler(IInboxStore inboxStore, ILogger logger)
    {
        _inboxStore = inboxStore;
        _logger = logger;
    }
    
    public async Task Handle(TEvent notification, CancellationToken ct)
    {
        var messageId = notification.EventId;
        
        // 1. 重複チェック
        if (await _inboxStore.IsProcessedAsync(messageId, ct))
        {
            _logger.LogInformation(
                "Duplicate event ignored: {EventType} [EventId: {EventId}]",
                typeof(TEvent).Name,
                messageId);
            return;
        }
        
        // 2. Inbox記録
        var inboxMessage = InboxMessage.Receive(
            messageId,
            typeof(TEvent).AssemblyQualifiedName!,
            notification);
        
        try
        {
            // 3. 実際の処理(派生クラスで実装)
            await HandleEventAsync(notification, ct);
            
            // 4. 成功マーク
            inboxMessage.MarkAsProcessed();
            await _inboxStore.SaveAsync(inboxMessage, ct);
            
            _logger.LogInformation(
                "Event processed: {EventType} [EventId: {EventId}]",
                typeof(TEvent).Name,
                messageId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex,
                "Failed to process event: {EventType} [EventId: {EventId}]",
                typeof(TEvent).Name,
                messageId);
            
            inboxMessage.MarkAsFailed(ex.Message);
            await _inboxStore.SaveAsync(inboxMessage, ct);
            
            throw;
        }
    }
    
    /// <summary>
    /// 派生クラスで実装する実際の処理
    /// </summary>
    protected abstract Task HandleEventAsync(TEvent @event, CancellationToken ct);
}

/// <summary>
/// 具体的なイベントハンドラー例
/// </summary>
public sealed class ProductDeletedIntegrationEventHandler 
    : InboxEventHandler<ProductDeletedIntegrationEvent>
{
    private readonly IHubContext<ProductsHub> _hubContext;
    private readonly ILogger<ProductDeletedIntegrationEventHandler> _logger;
    
    public ProductDeletedIntegrationEventHandler(
        IInboxStore inboxStore,
        IHubContext<ProductsHub> hubContext,
        ILogger<ProductDeletedIntegrationEventHandler> logger)
        : base(inboxStore, logger)
    {
        _hubContext = hubContext;
        _logger = logger;
    }
    
    protected override async Task HandleEventAsync(
        ProductDeletedIntegrationEvent @event,
        CancellationToken ct)
    {
        // SignalRで全クライアントに通知
        await _hubContext.Clients.All.SendAsync(
            "ProductDeleted",
            @event.ProductId,
            ct);
        
        _logger.LogInformation(
            "Notified all clients about product deletion: {ProductId}",
            @event.ProductId);
    }
}

/// <summary>
/// 統合イベント基底クラス
/// </summary>
public abstract record IntegrationEvent
{
    public string EventId { get; init; } = Guid.NewGuid().ToString();
    public DateTime OccurredAt { get; init; } = DateTime.UtcNow;
}

public sealed record ProductDeletedIntegrationEvent(
    Guid ProductId,
    DateTime DeletedAt,
    string DeletedBy
) : IntegrationEvent;
```

### 11.3 SAGA Pattern(分散トランザクション)

#### **データベーススキーマ**

```sql
CREATE TABLE OrderProcessSagas (
    SagaId UNIQUEIDENTIFIER PRIMARY KEY,
    OrderId UNIQUEIDENTIFIER NOT NULL,
    Status INT NOT NULL, -- 0:InProgress, 1:Completed, 2:Compensating, 3:Compensated, 4:Failed
    CurrentStep INT NOT NULL,
    StartedAt DATETIME2 NOT NULL,
    CompletedAt DATETIME2 NULL,
    INDEX IX_OrderId (OrderId),
    INDEX IX_Status (Status)
);

CREATE TABLE SagaStepRecords (
    Id UNIQUEIDENTIFIER PRIMARY KEY,
    SagaId UNIQUEIDENTIFIER NOT NULL,
    Step INT NOT NULL,
    Status INT NOT NULL, -- 1:Completed, 2:Failed, 3:Compensated
    CompletedAt DATETIME2 NOT NULL,
    DataJson NVARCHAR(MAX) NULL,
    ErrorMessage NVARCHAR(MAX) NULL,
    FOREIGN KEY (SagaId) REFERENCES OrderProcessSagas(SagaId)
);
```

#### **完全実装**

```csharp
/// <summary>
/// 注文処理SAGA
/// ステップ: 在庫引当 → 決済 → 配送手配
/// </summary>
public sealed class OrderProcessSaga
{
    public Guid SagaId { get; private set; }
    public Guid OrderId { get; private set; }
    public SagaStatus Status { get; private set; }
    public SagaStep CurrentStep { get; private set; }
    public DateTime StartedAt { get; private set; }
    public DateTime? CompletedAt { get; private set; }
    
    private readonly List<SagaStepRecord> _steps = new();
    public IReadOnlyList<SagaStepRecord> Steps => _steps.AsReadOnly();
    
    private OrderProcessSaga() { }
    
    public static OrderProcessSaga Start(Guid orderId)
    {
        return new OrderProcessSaga
        {
            SagaId = Guid.NewGuid(),
            OrderId = orderId,
            Status = SagaStatus.InProgress,
            CurrentStep = SagaStep.ReserveInventory,
            StartedAt = DateTime.UtcNow
        };
    }
    
    public void RecordStepCompleted(SagaStep step, object data)
    {
        _steps.Add(new SagaStepRecord
        {
            Id = Guid.NewGuid(),
            SagaId = SagaId,
            Step = step,
            Status = StepStatus.Completed,
            CompletedAt = DateTime.UtcNow,
            DataJson = JsonSerializer.Serialize(data)
        });
        
        // 次のステップに進む
        CurrentStep = step switch
        {
            SagaStep.ReserveInventory => SagaStep.ProcessPayment,
            SagaStep.ProcessPayment => SagaStep.ArrangeShipping,
            SagaStep.ArrangeShipping => SagaStep.Completed,
            _ => throw new InvalidOperationException($"Invalid step: {step}")
        };
        
        if (CurrentStep == SagaStep.Completed)
        {
            Status = SagaStatus.Completed;
            CompletedAt = DateTime.UtcNow;
        }
    }
    
    public void RecordStepFailed(SagaStep step, string error)
    {
        _steps.Add(new SagaStepRecord
        {
            Id = Guid.NewGuid(),
            SagaId = SagaId,
            Step = step,
            Status = StepStatus.Failed,
            CompletedAt = DateTime.UtcNow,
            ErrorMessage = error
        });
        
        Status = SagaStatus.Compensating;
    }
    
    public void RecordStepCompensated(SagaStep step)
    {
        _steps.Add(new SagaStepRecord
        {
            Id = Guid.NewGuid(),
            SagaId = SagaId,
            Step = step,
            Status = StepStatus.Compensated,
            CompletedAt = DateTime.UtcNow
        });
    }
    
    public void MarkAsCompensated()
    {
        Status = SagaStatus.Compensated;
        CompletedAt = DateTime.UtcNow;
    }
    
    public void MarkAsFailed()
    {
        Status = SagaStatus.Failed;
        CompletedAt = DateTime.UtcNow;
    }
}

/// <summary>
/// SAGAプロセスマネージャー
/// </summary>
public sealed class OrderProcessManager
{
    private readonly ISagaRepository _sagaRepo;
    private readonly IMediator _mediator;
    private readonly ILogger<OrderProcessManager> _logger;
    
    public async Task<Result> StartOrderProcessAsync(Guid orderId, CancellationToken ct)
    {
        // SAGAã''é–‹å§‹
        var saga = OrderProcessSaga.Start(orderId);
        await _sagaRepo.SaveAsync(saga, ct);
        
        _logger.LogInformation(
            "SAGA started: {SagaId} for Order: {OrderId}",
            saga.SagaId,
            orderId);
        
        // 最初のステップを実行
        await ExecuteNextStepAsync(saga, ct);
        
        return Result.Success();
    }
    
    private async Task ExecuteNextStepAsync(OrderProcessSaga saga, CancellationToken ct)
    {
        try
        {
            object result = saga.CurrentStep switch
            {
                SagaStep.ReserveInventory => await ExecuteReserveInventoryAsync(saga.OrderId, ct),
                SagaStep.ProcessPayment => await ExecuteProcessPaymentAsync(saga.OrderId, ct),
                SagaStep.ArrangeShipping => await ExecuteArrangeShippingAsync(saga.OrderId, ct),
                _ => throw new InvalidOperationException($"Unknown step: {saga.CurrentStep}")
            };
            
            // ステップ成功を記録
            saga.RecordStepCompleted(saga.CurrentStep, result);
            await _sagaRepo.SaveAsync(saga, ct);
            
            _logger.LogInformation(
                "SAGA step completed: {Step} [SagaId: {SagaId}]",
                saga.CurrentStep,
                saga.SagaId);
            
            // 次のステップがあれば実行
            if (saga.CurrentStep != SagaStep.Completed)
            {
                await ExecuteNextStepAsync(saga, ct);
            }
            else
            {
                _logger.LogInformation(
                    "SAGA completed successfully: {SagaId}",
                    saga.SagaId);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex,
                "SAGA step failed: {Step} [SagaId: {SagaId}]",
                saga.CurrentStep,
                saga.SagaId);
            
            saga.RecordStepFailed(saga.CurrentStep, ex.Message);
            await _sagaRepo.SaveAsync(saga, ct);
            
            // 補償処理を開始
            await CompensateAsync(saga, ct);
        }
    }
    
    private async Task CompensateAsync(OrderProcessSaga saga, CancellationToken ct)
    {
        _logger.LogWarning(
            "Starting compensation for SAGA: {SagaId}",
            saga.SagaId);
        
        // 完了したステップを逆順で補償
        var completedSteps = saga.Steps
            .Where(s => s.Status == StepStatus.Completed)
            .OrderByDescending(s => s.Step)
            .ToList();
        
        foreach (var step in completedSteps)
        {
            try
            {
                await CompensateStepAsync(saga.OrderId, step.Step, ct);
                saga.RecordStepCompensated(step.Step);
                await _sagaRepo.SaveAsync(saga, ct);
                
                _logger.LogInformation(
                    "Compensated step: {Step} [SagaId: {SagaId}]",
                    step.Step,
                    saga.SagaId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "Compensation failed: {Step} [SagaId: {SagaId}]",
                    step.Step,
                    saga.SagaId);
                
                // 補償失敗: アラート発火
                saga.MarkAsFailed();
                await _sagaRepo.SaveAsync(saga, ct);
                throw new SagaCompensationException(
                    $"Failed to compensate step {step.Step} for SAGA {saga.SagaId}",
                    ex);
            }
        }
        
        saga.MarkAsCompensated();
        await _sagaRepo.SaveAsync(saga, ct);
        
        _logger.LogInformation(
            "SAGA compensation completed: {SagaId}",
            saga.SagaId);
    }
    
    // 各ステップの実装
    private async Task<ReserveInventoryResult> ExecuteReserveInventoryAsync(
        Guid orderId,
        CancellationToken ct)
    {
        var command = new ReserveInventoryCommand(orderId);
        var result = await _mediator.Send(command, ct);
        
        if (!result.IsSuccess)
            throw new SagaStepException($"在庫引当失敗: {result.Error}");
        
        return result.Value;
    }
    
    private async Task<PaymentResult> ExecuteProcessPaymentAsync(
        Guid orderId,
        CancellationToken ct)
    {
        var command = new ProcessPaymentCommand(orderId);
        var result = await _mediator.Send(command, ct);
        
        if (!result.IsSuccess)
            throw new SagaStepException($"決済処理失敗: {result.Error}");
        
        return result.Value;
    }
    
    private async Task<ShippingResult> ExecuteArrangeShippingAsync(
        Guid orderId,
        CancellationToken ct)
    {
        var command = new ArrangeShippingCommand(orderId);
        var result = await _mediator.Send(command, ct);
        
        if (!result.IsSuccess)
            throw new SagaStepException($"配送手配失敗: {result.Error}");
        
        return result.Value;
    }
    
    // 補償アクション
    private async Task CompensateStepAsync(
        Guid orderId,
        SagaStep step,
        CancellationToken ct)
    {
        switch (step)
        {
            case SagaStep.ReserveInventory:
                await _mediator.Send(new ReleaseInventoryCommand(orderId), ct);
                break;
            
            case SagaStep.ProcessPayment:
                await _mediator.Send(new RefundPaymentCommand(orderId), ct);
                break;
            
            case SagaStep.ArrangeShipping:
                await _mediator.Send(new CancelShippingCommand(orderId), ct);
                break;
        }
    }
}

public class SagaStepException : Exception
{
    public SagaStepException(string message) : base(message) { }
}

public class SagaCompensationException : Exception
{
    public SagaCompensationException(string message, Exception inner) 
        : base(message, inner) { }
}
```

---
