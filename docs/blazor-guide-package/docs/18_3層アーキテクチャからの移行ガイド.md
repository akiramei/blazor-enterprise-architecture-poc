# 18. 3層アーキテクチャからの移行ガイド

[← 目次に戻る](00_README.md)

---

## 18. 3層アーキテクチャからの移行ガイド

このガイドは、**WPF/WinForms + RESTful Web API** の3層アーキテクチャ経験者が、このBlazor Enterprise Architectureをスムーズに理解するためのものです。

### 16.1 あなたが知っている技術との対応表

#### **全体構造の比較**

| 3層アーキテクチャ | このアーキテクチャ | 主な違い |
|-----------------|-----------------|---------|
| **Presentation層** | **UI層（Blazor）** | WPF/WinFormsからBlazorへ |
| **Business Logic層/Service層** | **Application層** | MediatRによる疎結合化 |
| **Data Access層** | **Infrastructure層** | ほぼ同じ概念 |

#### **クライアント側（WPF/WinForms → Blazor）の対応**

| WPF/WinForms | このアーキテクチャ | 概念の違い |
|-------------|-----------------|-----------|
| **UserControl** | **Dumb Component** | ほぼ同じ。表示のみを担当 |
| **Window/Form** | **Smart Component** | イベントハンドリングのみ、I/Oは委譲 |
| **ViewModel** | **Store** + **PageActions** | 責務を2つに分離（後述） |
| **ICommand** | **PageActions のメソッド** | より明示的な命名 |
| **INotifyPropertyChanged** | **Store.OnChangeAsync イベント** | 不変状態 + イベント駆動 |
| **DataBinding** | **@State.Property** | 一方向バインディング |
| **Dependency Property** | **[Parameter]** | Componentへのデータ渡し |
| **RoutedEvent** | **EventCallback** | 子→親へのイベント伝播 |

#### **サーバー側（Service層 → Application層）の対応**

| 3層アーキテクチャ | このアーキテクチャ | 概念の違い |
|-----------------|-----------------|-----------|
| **ProductService** | **Handlers（複数）** | 単一責任に分割 |
| **ServiceクラスのDI** | **MediatR経由の呼び出し** | 疎結合、Pipeline適用可能 |
| **GetProduct()メソッド** | **GetProductQuery + Handler** | CQRS: Query |
| **DeleteProduct()メソッド** | **DeleteProductCommand + Handler** | CQRS: Command |
| **Validator** | **FluentValidation Validator** | 同じ概念 |
| **[Authorize]属性** | **AuthorizationBehavior** | Pipeline Behavior |
| **TransactionScope** | **TransactionBehavior** | Pipeline Behavior |

#### **データアクセス層の対応**

| 3層アーキテクチャ | このアーキテクチャ | 概念の違い |
|-----------------|-----------------|-----------|
| **Repository** | **Repository** | 同じ概念 |
| **DbContext** | **DbContext** | 同じ |
| **DTO** | **DTO** | 同じ |
| **Entity** | **Domain Entity（集約ルート）** | DDDの概念を追加 |

---

### 16.2 なぜViewModelを分割するのか？ - Store vs PageActions

#### **WPFのViewModel（従来）**

```csharp
// ViewModelがすべてを担当（肥大化しやすい）
public class ProductListViewModel : INotifyPropertyChanged
{
    // ===== 状態管理 =====
    private ObservableCollection<Product> _products = new();
    public ObservableCollection<Product> Products
    {
        get => _products;
        set
        {
            _products = value;
            OnPropertyChanged();
        }
    }

    private bool _isLoading;
    public bool IsLoading
    {
        get => _isLoading;
        set
        {
            _isLoading = value;
            OnPropertyChanged();
        }
    }

    // ===== UI手順 =====
    public ICommand DeleteCommand { get; }

    private async Task DeleteProductAsync(Guid id)
    {
        // 確認ダイアログ
        var result = MessageBox.Show("削除しますか?", "確認", MessageBoxButton.YesNo);
        if (result != MessageBoxResult.Yes) return;

        // I/O処理
        IsLoading = true;
        try
        {
            await _productService.DeleteAsync(id);
            Products.Remove(Products.First(p => p.Id == id));
            MessageBox.Show("削除しました");
        }
        catch (Exception ex)
        {
            MessageBox.Show($"エラー: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
        }
    }

    public event PropertyChangedEventHandler? PropertyChanged;
}
```

**❌ 問題点:**
- 状態管理、UI手順、I/O処理がすべて1クラスに集中
- テストが困難（MessageBox、I/O処理が混在）
- 再利用性が低い
- 並行制御が難しい

---

#### **このアーキテクチャ（Store + PageActions）**

```csharp
// ===== Store: 状態管理のみ =====
public class ProductsStore
{
    private readonly IServiceScopeFactory _scopeFactory;
    private ProductsState _state = new();

    public event Func<Task>? OnChangeAsync;  // INotifyPropertyChangedの代替

    // 状態の取得（不変）
    public ProductsState GetState() => _state;

    // I/O処理と状態更新
    public async Task<bool> DeleteAsync(Guid id, CancellationToken ct = default)
    {
        using var scope = _scopeFactory.CreateScope();
        var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();

        var result = await mediator.Send(new DeleteProductCommand(id), ct);

        if (result.IsSuccess)
        {
            await LoadAsync(ct);  // 最新状態を再取得
        }

        return result.IsSuccess;
    }

    private void SetState(ProductsState newState)
    {
        _state = newState;
        OnChangeAsync?.Invoke();  // UI再描画をトリガー
    }
}

// ===== 不変State =====
public record ProductsState
{
    public ImmutableList<ProductDto> Products { get; init; } = ImmutableList<ProductDto>.Empty;
    public bool IsLoading { get; init; }
    public string? ErrorMessage { get; init; }
}

// ===== PageActions: UI手順のみ =====
public class ProductListActions
{
    private readonly ProductsStore _store;
    private readonly IConfirmDialog _confirm;  // MessageBoxの代替（DI可能）
    private readonly IToast _toast;

    public async Task DeleteAsync(Guid id, CancellationToken ct = default)
    {
        // 1. 確認ダイアログ（テスト可能）
        if (!await _confirm.ShowAsync("削除しますか?")) return;

        // 2. I/O処理はStoreに完全委譲
        var result = await _store.DeleteAsync(id, ct);

        // 3. 結果表示（テスト可能）
        if (result) _toast.Success("削除しました");
        else _toast.Error("削除に失敗しました");
    }
}
```

**✅ メリット:**
- **Store**: 純粋な状態管理とI/O → 単体テスト容易
- **PageActions**: UI手順のみ → モックで完全にテスト可能
- **不変State**: バグの原因となるミューテーションを防止
- **再利用性**: 複数のコンポーネントで同じStoreを共有可能
- **並行制御**: Storeで一元管理

---

### 16.3 なぜMediatRを使うのか？ - Serviceクラスの直接DIとの違い

#### **従来の3層アーキテクチャ（Serviceクラス直接DI）**

```csharp
// ===== Controller/ViewModel =====
public class ProductsController : Controller
{
    private readonly IProductService _productService;
    private readonly ILogger<ProductsController> _logger;
    private readonly IAuthorizationService _authService;

    public async Task<IActionResult> Delete(Guid id)
    {
        // 1. ログ出力（横断的関心事）
        _logger.LogInformation("商品削除開始: {ProductId}", id);

        // 2. 認可チェック（横断的関心事）
        var authResult = await _authService.AuthorizeAsync(User, "DeleteProduct");
        if (!authResult.Succeeded)
        {
            _logger.LogWarning("認可失敗: {ProductId}", id);
            return Forbid();
        }

        // 3. バリデーション（横断的関心事）
        if (id == Guid.Empty)
        {
            return BadRequest("IDが不正です");
        }

        // 4. ビジネスロジック
        try
        {
            await _productService.DeleteAsync(id);
            _logger.LogInformation("商品削除完了: {ProductId}", id);
            return Ok();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "商品削除失敗: {ProductId}", id);
            return StatusCode(500);
        }
    }
}

// ===== Service層 =====
public class ProductService : IProductService
{
    private readonly IProductRepository _repository;
    private readonly AppDbContext _dbContext;

    public async Task DeleteAsync(Guid id)
    {
        // トランザクション開始（横断的関心事）
        using var transaction = await _dbContext.Database.BeginTransactionAsync();

        try
        {
            var product = await _repository.GetAsync(id);
            if (product == null) throw new NotFoundException();

            await _repository.DeleteAsync(product);
            await _dbContext.SaveChangesAsync();

            // トランザクションコミット
            await transaction.CommitAsync();
        }
        catch
        {
            await transaction.RollbackAsync();
            throw;
        }
    }
}
```

**❌ 問題点:**
1. **横断的関心事が各メソッドに散在**
   - ログ、認可、バリデーション、トランザクションのコードが重複
   - 新しいメソッドを追加するたびにコピペ

2. **追加機能の実装が困難**
   - 監査ログを追加したい → すべてのメソッドを修正
   - メトリクス収集を追加したい → すべてのメソッドを修正

3. **テストが困難**
   - 横断的関心事とビジネスロジックが混在

---

#### **このアーキテクチャ（MediatR + Pipeline Behaviors）**

```csharp
// ===== UI層/Store =====
// たった1行でCommand送信
var result = await _mediator.Send(new DeleteProductCommand(productId), ct);

// ===== Application層: Handler（ビジネスロジックのみ！）=====
public class DeleteProductHandler : IRequestHandler<DeleteProductCommand, Result>
{
    private readonly IProductRepository _repository;

    // 横断的関心事は一切書かない！Pipeline Behaviorsが自動適用
    public async Task<Result> Handle(DeleteProductCommand command, CancellationToken ct)
    {
        var product = await _repository.GetAsync(new ProductId(command.ProductId), ct);
        if (product is null) return Result.Fail("商品が見つかりません");

        product.Delete();  // ドメインルール適用
        await _repository.SaveAsync(product, ct);

        return Result.Success();
    }
}

// ===== Infrastructure層: Pipeline Behaviors（自動適用）=====
// Program.csで登録するだけで、すべてのCommand/Queryに適用される
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(MetricsBehavior<,>));        // 0. メトリクス収集
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));        // 1. ログ出力
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));     // 2. バリデーション
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(AuthorizationBehavior<,>));  // 3. 認可チェック
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(IdempotencyBehavior<,>));    // 4. 冪等性保証
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(CachingBehavior<,>));        // 5. キャッシング
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(AuditLogBehavior<,>));       // 6. 監査ログ
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(TransactionBehavior<,>));    // 7. トランザクション
```

**✅ メリット:**

1. **横断的関心事が1箇所に集約**
   - すべてのCommand/Queryに自動適用
   - コードの重複がゼロ

2. **追加機能の実装が容易**
   - 監査ログを追加したい → `AuditLogBehavior`を追加するだけ
   - メトリクス収集を追加したい → `MetricsBehavior`を追加するだけ
   - **既存のHandler一切修正不要**

3. **Handlerがビジネスロジックに集中**
   - テストが容易（ビジネスロジックのみをテスト）
   - 可読性が高い

4. **実行順序を制御可能**
   - Pipeline Behaviorsの登録順序で実行順序が決まる
   - 例: Validation → Authorization → Transaction の順序を保証

---

### 16.4 なぜCQRSを使うのか？ - メソッド分離との違い

#### **従来の3層アーキテクチャ（同一Service内のメソッド分離）**

```csharp
public interface IProductService
{
    // 読み取り
    Task<Product> GetProductAsync(Guid id);
    Task<IEnumerable<Product>> GetAllProductsAsync();
    Task<IEnumerable<Product>> SearchProductsAsync(string keyword);

    // 書き込み
    Task CreateProductAsync(Product product);
    Task UpdateProductAsync(Product product);
    Task DeleteProductAsync(Guid id);
}

public class ProductService : IProductService
{
    // すべてのメソッドが1つのクラスに集約
    // 読み取りも書き込みも同じDbContext、同じトランザクション
}
```

**⚠️ 問題点:**
- 読み取りと書き込みが同じトランザクション管理
- 読み取り用の最適化（Dapper、AsNoTracking等）が適用しにくい
- キャッシュ戦略が適用しにくい
- 責務が不明確

---

#### **このアーキテクチャ（CQRS: Command/Query分離）**

```csharp
// ===== Query（読み取り）=====
public record GetProductsQuery : IQuery<Result<IEnumerable<ProductDto>>>;

public class GetProductsHandler : IRequestHandler<GetProductsQuery, Result<IEnumerable<ProductDto>>>
{
    private readonly IProductReadRepository _readRepository;  // 読み取り専用Repository

    public async Task<Result<IEnumerable<ProductDto>>> Handle(GetProductsQuery query, CancellationToken ct)
    {
        // Dapperで高速読み取り、AsNoTrackingでトラッキング無効化
        var products = await _readRepository.GetAllAsync(ct);
        return Result<IEnumerable<ProductDto>>.Success(products);
    }
}

// ===== Command（書き込み）=====
public record DeleteProductCommand(Guid ProductId) : ICommand<Result>;

public class DeleteProductHandler : IRequestHandler<DeleteProductCommand, Result>
{
    private readonly IProductRepository _repository;  // 書き込み用Repository

    public async Task<Result> Handle(DeleteProductCommand command, CancellationToken ct)
    {
        // EF Coreでトラッキング、ビジネスルール適用
        var product = await _repository.GetAsync(new ProductId(command.ProductId), ct);
        product.Delete();
        await _repository.SaveAsync(product, ct);
        return Result.Success();
    }
}
```

**✅ メリット:**

| 観点 | Query（読み取り） | Command（書き込み） |
|------|----------------|------------------|
| **Repository** | IProductReadRepository（Dapper） | IProductRepository（EF Core） |
| **トラッキング** | AsNoTracking | トラッキング有効 |
| **トランザクション** | 不要 | TransactionBehaviorで自動管理 |
| **キャッシュ** | CachingBehaviorで自動適用 | 適用しない |
| **ビジネスルール** | 適用しない | Domainで適用 |
| **最適化** | JOIN、射影、ページング | 集約ルート全体を取得 |

**具体例: 性能差**

```csharp
// Query: Dapper + AsNoTracking（高速）
SELECT p.Id, p.Name, p.Price, p.Stock
FROM Products p
WHERE p.IsActive = true;
// → 1,000件で 10ms

// Command: EF Core + トラッキング + 集約全体
var product = await _context.Products
    .Include(p => p.Images)
    .FirstOrDefaultAsync(p => p.Id == id);
// → 1件で 50ms（トラッキングとIncludeのオーバーヘッド）
```

---

### 16.5 段階的な学習パス（推奨）

#### **Step 1: 既知の概念から始める（30分）**

1. **レイヤー構成の確認**
   - [07_レイヤー構成と責務](07_レイヤー構成と責務.md)
   - 3層アーキテクチャとの対応を確認

2. **Repository/DbContextの確認**
   - [12_Infrastructure層の詳細設計](12_Infrastructure層の詳細設計.md)
   - Data Access層との違いを確認（ほぼ同じ）

---

#### **Step 2: UI層の新パターンを理解（1時間）**

1. **Dumb Component**
   - [09_UI層の詳細設計 - 9.1節](09_UI層の詳細設計.md#91-dumb-component純粋表示コンポーネント)
   - WPFのUserControlと同じ概念

2. **Smart Component**
   - [09_UI層の詳細設計 - 9.2節](09_UI層の詳細設計.md#92-smart-componentページコンポーネント)
   - WPFのWindowと同じ概念

3. **Store（状態管理）**
   - [09_UI層の詳細設計 - 9.4節](09_UI層の詳細設計.md#94-store状態管理とio)
   - ViewModelの状態管理部分を分離

4. **PageActions（UI手順）**
   - [09_UI層の詳細設計 - 9.3節](09_UI層の詳細設計.md#93-pageactionsui手順オーケストレーション)
   - ViewModelのICommand部分を分離

**重要な違い:**
- WPFのViewModel = Store（状態管理） + PageActions（UI手順）に分離
- なぜ分離？ → テスタビリティと再利用性の向上

---

#### **Step 3: MediatRとCQRSを理解（1時間）**

1. **なぜMediatRが必要か**
   - この章の16.3節を参照
   - Pipeline Behaviorsによる横断的関心事の統一

2. **CQRSとは何か**
   - この章の16.4節を参照
   - 読み取りと書き込みの最適化を独立して実施

3. **Pipeline Behaviorsの詳細**
   - [10_Application層の詳細設計](10_Application層の詳細設計.md)
   - ログ、バリデーション、認可、トランザクション等の自動適用

---

#### **Step 4: 横断的関心事を理解（30分）**

1. **Pipeline Behaviorsの仕組み**
   - [10_Application層の詳細設計](10_Application層の詳細設計.md) - Pipeline Behaviors参照
   - Attribute/Filterとの違いと利点

2. **監査ログ・メトリクス**
   - エンタープライズアプリケーション要件
   - 実装済みの機能を確認

---

#### **Step 5: ドメイン駆動設計（DDD）の基礎（1時間）**

1. **集約ルート・エンティティ・値オブジェクト**
   - [11_Domain層の詳細設計](11_Domain層の詳細設計.md)
   - 従来のEntityとの違い

2. **ドメインイベント**
   - ビジネスルールの明示化
   - 疎結合な機能連携

---

#### **Step 6: 実装パターンを確認（30分）**

1. **具体例で全体を理解**
   - [08_具体例_商品管理機能](08_具体例_商品管理機能.md)
   - Create/Read/Update/Delete の全パターン

2. **パターンカタログ**
   - [05_パターンカタログ一覧](05_パターンカタログ一覧.md)
   - 実装時のクイックリファレンス

---

### 16.6 よくある疑問（FAQ）

#### **Q1: ServiceクラスのDIではダメなのか？**

**A:** 小規模アプリケーションであれば問題ありません。しかし、以下の場合はMediatRが有利です：

- チーム開発（5名以上）
- 長期保守（3年以上）
- エンタープライズ要件（監査ログ、メトリクス、認可等）
- 複雑なビジネスロジック

**MediatRのメリット:**
- 横断的関心事の統一（Pipeline Behaviors）
- 単一責任の原則（1 Handler = 1 UseCase）
- テスタビリティの向上

---

#### **Q2: ViewModelを分割するメリットは？**

**A:** Store（状態管理） + PageActions（UI手順）に分割することで：

- **テスタビリティ**: Storeは純粋関数、Actionsは単体テスト可能
- **再利用性**: 複数コンポーネントで同じStoreを共有
- **単一責任**: 状態管理とUI手順を分離
- **並行制御**: Storeで一元管理

WPFのViewModelは肥大化しやすい問題がありますが、この分離により解決します。

---

#### **Q3: CQRSは必須か？**

**A:** 必須ではありませんが、以下の場合は強く推奨：

- 読み取りと書き込みの頻度が大きく異なる
- 読み取り性能が重要（検索、レポート等）
- キャッシュ戦略を適用したい
- 読み取りと書き込みで異なるデータモデルが必要

**CQRSのメリット:**
- 読み取りと書き込みを独立して最適化
- キャッシュ戦略の適用が容易
- 責務が明確

---

#### **Q4: Blazorは学習コストが高いのでは？**

**A:** WPF/WinForms経験者であれば学習コストは低いです：

| WPF/WinForms | Blazor | 学習難易度 |
|-------------|--------|----------|
| XAML | Razor | 低（似ている） |
| Code-behind | @code | 低（同じC#） |
| DataBinding | 手動バインディング | 中（異なるが簡単） |
| UserControl | Dumb Component | 低（同じ概念） |

Blazor特有の概念（SignalR、Circuit等）は段階的に学べます。

---

#### **Q5: 既存の3層アプリケーションから移行できるか？**

**A:** はい、段階的に移行可能です：

**段階1: UI層のみBlazorに移行**
- バックエンドはそのまま（RESTful API）
- BlazorからHTTPClientでAPI呼び出し

**段階2: Application層をMediatRに移行**
- ServiceクラスをHandlerに分割
- Pipeline Behaviorsを追加

**段階3: Domain層をDDDに移行**
- 集約ルート、値オブジェクトの導入
- ビジネスルールのドメインへの移動

各段階は独立しており、段階的に移行可能です。

---

## まとめ

このアーキテクチャは、3層アーキテクチャの進化形です。

**主な進化点:**
1. **MediatR**: 横断的関心事の統一と疎結合化
2. **CQRS**: 読み取りと書き込みの独立した最適化
3. **Store/Actions分離**: ViewModelの責務分離
4. **Pipeline Behaviors**: 宣言的な横断的関心事の適用
5. **DDD**: ビジネスルールのドメインへの集約

これらの進化により、**エンタープライズグレードの要件（監査、メトリクス、認可、トランザクション等）を満たしながら、テスタビリティと保守性を確保**できます。

---

**次のステップ:**
- [01_イントロダクション](01_イントロダクション.md)で全体像を確認
- [08_具体例_商品管理機能](08_具体例_商品管理機能.md)で実装パターンを確認
- [09_UI層の詳細設計](09_UI層の詳細設計.md)でBlazor実装を学習
