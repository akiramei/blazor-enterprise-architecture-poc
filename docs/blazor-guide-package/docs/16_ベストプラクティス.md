# 16. ベストプラクティス

[← 目次に戻る](00_README.md)

---

## 16. ベストプラクティス

### 14.1 依存性注入のスコープ

```csharp
// ✅ 正しいスコープ設定

// Blazor Server Circuit単位
builder.Services.AddScoped<ProductsStore>();
builder.Services.AddScoped<ProductListActions>();

// 都度スコープで解決
builder.Services.AddScoped<AppDbContext>();
builder.Services.AddScoped<IMediator, Mediator>();

// Singleton(ステートレス)
builder.Services.AddSingleton<IIdGenerator, GuidGenerator>();

// Transient(軽量・ステートレス)
builder.Services.AddTransient<ICurrentUserService, CurrentUserService>();
```

### 14.2 エラーハンドリング

```csharp
// ✅ Result型による明示的なエラーハンドリング

public sealed record Result
{
    public bool IsSuccess { get; }
    public string? Error { get; }
    
    private Result(bool isSuccess, string? error)
    {
        IsSuccess = isSuccess;
        Error = error;
    }
    
    public static Result Success() => new(true, null);
    public static Result Fail(string error) => new(false, error);
}

public sealed record Result<T> : Result
{
    public T? Value { get; }
    
    private Result(bool isSuccess, T? value, string? error) : base(isSuccess, error)
    {
        Value = value;
    }
    
    public static Result<T> Success(T value) => new(true, value, null);
    public new static Result<T> Fail(string error) => new(false, default, error);
}
```

### 14.3 ロギング戦略

```csharp
// ✅ 構造化ロギング

_logger.LogInformation(
    "商品を削除しました: {ProductId}, ユーザー: {UserId}",
    productId,
    userId);

// ✅ ログレベルの適切な使い分け
// - Trace: 詳細なデバッグ情報
// - Debug: 開発時のデバッグ
// - Information: 正常な動作フロー
// - Warning: 予期しないが回復可能な状態
// - Error: エラー(例外)
// - Critical: 致命的なエラー
```

### 14.4 セキュリティ

```csharp
// ✅ 認可の一貫性

// 1. Command/Queryレベル
[Authorize(Roles = "Admin")]
public sealed record DeleteProductCommand(Guid ProductId) : ICommand<Result>;

// 2. UI レベル(ボタン非表示)
@if (CurrentUser.IsInRole("Admin"))
{
    <button @onclick="() => Actions.DeleteAsync(product.Id)">削除</button>
}

// 3. 多層防御
// - UI: ボタン非表示
// - PageActions: 追加チェック(オプション)
// - AuthorizationBehavior: 必須チェック
// - Handler: ビジネスルールチェック
```

### 14.5 設定管理

```json
// appsettings.json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=...;Database=...",
    "ReadOnlyConnection": "Server=replica...;ApplicationIntent=ReadOnly"
  },
  "Caching": {
    "ProductList": {
      "DurationMinutes": 5
    },
    "ProductDetail": {
      "DurationMinutes": 10
    }
  },
  "CircuitOptions": {
    "MaxRetainedDisconnectedCircuits": 100,
    "DisconnectedCircuitRetentionMinutes": 3
  }
}
```

### 14.6 Blazor Server運用ガイド(安全策集約) (v2.1改善)

**Blazor Server特有の注意点を一元化**

#### 14.6.1 再接続時の安全策

```csharp
// 1. Store再初期化の実装
public sealed class ProductsStore : IDisposable
{
    private bool _isInitialized;
    
    public async Task EnsureInitializedAsync(CancellationToken ct = default)
    {
        if (_isInitialized) return;
        
        await LoadAsync(ct);
        _isInitialized = true;
    }
}

// 2. Smart Componentでの利用
@code {
    protected override async Task OnInitializedAsync()
    {
        Store.OnChangeAsync += HandleStateChanged;
        
        // ✅ 再接続時にも初期化を保証
        await Store.EnsureInitializedAsync();
    }
    
    // ✅ 再接続検知とリロード
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // SignalR再接続イベントを購読
            await JSRuntime.InvokeVoidAsync("blazorReconnectHandler.register", 
                DotNetObjectReference.Create(this));
        }
    }
    
    [JSInvokable]
    public async Task OnReconnected()
    {
        _logger.LogInformation("SignalR再接続完了、データを再読込");
        await Store.LoadAsync();
    }
}

// JavaScript側(wwwroot/js/reconnect-handler.js)
window.blazorReconnectHandler = {
    register: function(dotNetHelper) {
        Blazor.defaultReconnectionHandler.onConnectionUp = async () => {
            await dotNetHelper.invokeMethodAsync('OnReconnected');
        };
    }
};
```

#### 14.6.2 回線断中の二重実行防止

```csharp
// Store側の防御
public sealed class ProductsStore
{
    private readonly SemaphoreSlim _gate = new(1, 1);
    private bool _isProcessing;
    
    public async Task<bool> DeleteAsync(Guid id, CancellationToken ct = default)
    {
        // ✅ 既に処理中なら拒否
        if (_isProcessing)
        {
            _logger.LogWarning("削除処理が既に実行中です");
            return false;
        }
        
        await _gate.WaitAsync(ct);
        try
        {
            _isProcessing = true;
            
            // ... 実際の削除処理
            
            return true;
        }
        finally
        {
            _isProcessing = false;
            _gate.Release();
        }
    }
}

// UI側の防御(ボタン無効化)
<button class="btn btn-danger" 
        @onclick="() => Actions.DeleteAsync(product.Id)"
        disabled="@_isDeleting">
    @if (_isDeleting)
    {
        <span class="spinner-border spinner-border-sm"></span>
    }
    削除
</button>

@code {
    private bool _isDeleting;
    
    private async Task HandleDelete(Guid id)
    {
        if (_isDeleting) return;  // ✅ 二重クリック防止
        
        _isDeleting = true;
        StateHasChanged();
        
        try
        {
            await Actions.DeleteAsync(id);
        }
        finally
        {
            _isDeleting = false;
            StateHasChanged();
        }
    }
}
```

#### 14.6.3 アンチフォージェリトークン

```csharp
// Program.cs
builder.Services.AddAntiforgery(options =>
{
    options.HeaderName = "X-CSRF-TOKEN";
    options.Cookie.Name = "__Host-X-CSRF-TOKEN";
    options.Cookie.SameSite = SameSiteMode.Strict;
    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
});

// _Host.cshtml または App.razor
<component type="typeof(App)" render-mode="ServerPrerendered" />
<script src="_framework/blazor.server.js" 
        asp-append-version="true"
        data-antiforgery-token="@Html.GetAntiforgeryToken()"></script>

// Blazor Component での利用
@inject IAntiforgery Antiforgery

@code {
    [CascadingParameter]
    private HttpContext? HttpContext { get; set; }
    
    private async Task SubmitFormAsync()
    {
        // ✅ トークン検証
        await Antiforgery.ValidateRequestAsync(HttpContext!);
        
        // ... フォーム送信処理
    }
}
```

#### 14.6.4 サーキットごとのIServiceScope作法

```csharp
// ❌ BAD: Storeに直接DbContextをDI
public class ProductsStore
{
    private readonly AppDbContext _context;  // ❌ Circuit寿命と同じになる
    
    public ProductsStore(AppDbContext context)
    {
        _context = context;  // メモリリークの原因
    }
}

// ✅ GOOD: IServiceScopeFactoryで都度スコープ作成
public class ProductsStore
{
    private readonly IServiceScopeFactory _scopeFactory;  // ✅ 推奨
    
    public async Task LoadAsync(CancellationToken ct)
    {
        // ✅ 新しいスコープを作成
        using var scope = _scopeFactory.CreateScope();
        var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
        
        // MediatorのPipeline内でDbContextが解決される
        var result = await mediator.Send(new GetProductsQuery(), ct);
        
        // スコープ終了時にDbContextが自動Dispose
    }
}

// ✅ GOOD: Handlerでの利用(スコープは自動管理)
public class GetProductsQueryHandler : IRequestHandler<GetProductsQuery, Result<...>>
{
    private readonly AppDbContext _context;  // ✅ OK: Handler寿命はリクエストスコープ
    
    public GetProductsQueryHandler(AppDbContext context)
    {
        _context = context;  // リクエストごとに新しいインスタンス
    }
    
    public async Task<Result<...>> Handle(GetProductsQuery query, CancellationToken ct)
    {
        // ... クエリ実行
    }
}
```

#### 14.6.5 Circuit健全性チェックリスト

**運用前に以下を確認**:

| 項目 | チェック内容 | 対策 |
|------|------------|------|
| **1. メモリリーク** | Storeに長寿命依存がないか | IServiceScopeFactory使用 |
| **2. イベント購読解除** | Dispose時に購読解除しているか | IDisposable実装 |
| **3. 再接続処理** | 再接続時の初期化ロジックがあるか | EnsureInitializedAsync実装 |
| **4. 二重実行防止** | 処理中フラグとセマフォがあるか | SemaphoreSlim + _isProcessing |
| **5. CSRF対策** | アンチフォージェリトークン使用 | IAntiforgery設定 |
| **6. Circuit制限** | 切断Circuit保持数を設定 | appsettings.json設定 |
| **7. タイムアウト設定** | JSInterop/SignalRタイムアウト | CircuitOptions設定 |
| **8. エラーログ** | Circuit切断/再接続をログ | ILogger使用 |

#### 14.6.6 運用設定の推奨値

```csharp
// Program.cs
builder.Services.AddServerSideBlazor(options =>
{
    // ✅ 本番環境推奨設定
    options.DetailedErrors = false;  // 本番はfalse
    options.DisconnectedCircuitMaxRetained = 100;  // 最大保持Circuit数
    options.DisconnectedCircuitRetentionPeriod = TimeSpan.FromMinutes(3);  // 保持時間
    options.JSInteropDefaultCallTimeout = TimeSpan.FromMinutes(1);  // JSタイムアウト
    options.MaxBufferedUnacknowledgedRenderBatches = 10;  // レンダリングバッファ
});

// appsettings.Production.json
{
  "CircuitOptions": {
    "MaxRetainedDisconnectedCircuits": 100,
    "DisconnectedCircuitRetentionMinutes": 3,
    "JSInteropTimeoutMinutes": 1
  },
  "Logging": {
    "LogLevel": {
      "Microsoft.AspNetCore.SignalR": "Warning",  // SignalRログを抑制
      "Microsoft.AspNetCore.Http.Connections": "Warning"
    }
  }
}
```

#### 14.6.7 トラブルシューティングガイド

**よくある問題と解決策**:

```csharp
// 問題1: "Circuit not found" エラー
// 原因: Circuit保持時間を超えた、またはサーバー再起動
// 解決策: 
// - DisconnectedCircuitRetentionPeriodを延長
// - 再接続時のEnsureInitializedAsync実装
// - ユーザーに再読込を促すUI表示

// 問題2: メモリ使用量の増加
// 原因: DbContextがCircuit寿命で保持されている
// 解決策:
// - StoreでIServiceScopeFactoryを使用
// - 不要なInclude/Trackingを削除
// - Circuit数を監視(メトリクス)

// 問題3: SignalR接続エラーの多発
// 原因: WebSocketsが無効、またはプロキシ問題
// 解決策:
// - WebSocketsを有効化
// - Long Pollingフォールバック設定
// - nginxなどのプロキシ設定確認

// 問題4: 再接続後にデータが古い
// 原因: 再接続時の再初期化が未実装
// 解決策:
// - OnReconnectedイベントで再読込
// - SignalRでのキャッシュ無効化通知
```

**監視すべきメトリクス**:

```csharp
// Application Insights / Prometheus メトリクス
// - active_circuits: アクティブなCircuit数
// - disconnected_circuits: 切断されたCircuit数
// - reconnection_count: 再接続回数
// - circuit_lifetime_seconds: Circuit寿命の分布
// - memory_per_circuit_mb: Circuit当たりのメモリ使用量
```

---


## 16.7 よくある落とし穴と解決策

### 16.7.1 Blazor Serverライフサイクルの誤解

**落とし穴:** `OnInitializedAsync`でJavaScript interopを呼ぶ

```csharp
// ❌ 間違い
protected override async Task OnInitializedAsync()
{
    await JS.InvokeVoidAsync("window.myFunction");
    // エラー: "JavaScript interop calls cannot be issued at this time"
}
```

**原因:**
- Blazor ServerのPrerenderingにより、サーバー側で静的HTML生成時に実行される
- この時点ではJavaScriptランタイムが存在しない

**解決策:**
```csharp
// ✅ 正しい
protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender)
    {
        await JS.InvokeVoidAsync("window.myFunction");
    }
}
```

**教訓:**
- JavaScript interopは**必ず**`OnAfterRenderAsync`で実行
- E2Eテストのready信号も`OnAfterRenderAsync`で設定
- これはReact/Vue/AngularのSSRでも同じパターン

---

### 16.7.2 EF Core IncludeとIgnore/OwnsMany

**落とし穴:** `Ignore`されたプロパティを`.Include()`で参照

```csharp
// EF Core設定
builder.Ignore(p => p.Images);
builder.OwnsMany<ProductImage>("_images", ...);

// ❌ 間違い
var products = await _context.Products.Include(p => p.Images).ToListAsync();
// エラー: "The expression 'p.Images' is invalid inside an 'Include' operation"
```

**原因:**
- EF Coreは`p.Images`が何を指しているか分からない（Ignoreされている）
- 実際にマッピングされているのは`_images`（privateフィールド）

**解決策:**
```csharp
// ✅ 正しい: OwnsMany関係は自動的にロードされる
var products = await _context.Products.ToListAsync();
```

**教訓:**
- `OwnsMany`関係のナビゲーションプロパティには`.Include()`不要
- Ignoreされたプロパティは参照できない

---

### 16.7.3 テストデータベースの不一致

**落とし穴:** 異なるDbContextで作成と読み取り

```csharp
// ❌ 間違い: テストでAppDbContextに作成
var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
await context.Products.AddAsync(product);

// リポジトリはProductCatalogDbContextから読む
public TestProductReadRepository(ProductCatalogDbContext context) { ... }
// 結果: データが見つからない（別々のInMemoryDB）
```

**原因:**
- InMemoryDatabaseは**DbContext毎に別々のインスタンス**
- `AppDbContext`と`ProductCatalogDbContext`は異なるDB

**解決策:**
```csharp
// ✅ 正しい: 同じDbContextを使用
var context = scope.ServiceProvider.GetRequiredService<ProductCatalogDbContext>();
await context.Products.AddAsync(product);
```

**教訓:**
- E2Eテストではリポジトリと同じDbContextを使用
- InMemoryDatabaseの挙動を理解する

---

### 16.7.4 Store購読のメモリリーク

**落とし穴:** `OnChangeAsync`イベントの購読解除忘れ

```csharp
// ❌ 間違い: Disposeで購読解除しない
protected override async Task OnInitializedAsync()
{
    Store.OnChangeAsync += HandleStateChanged;
    // Disposeなし → メモリリーク
}
```

**原因:**
- イベントハンドラーがコンポーネントを参照し続ける
- コンポーネントがGCされない

**解決策:**
```csharp
// ✅ 正しい: Disposeで購読解除
@implements IDisposable

protected override async Task OnInitializedAsync()
{
    Store.OnChangeAsync += HandleStateChanged;
}

public void Dispose()
{
    Store.OnChangeAsync -= HandleStateChanged;
}
```

**教訓:**
- `OnChangeAsync`購読は**必ず**`Dispose`で解除
- `IDisposable`実装は忘れずに

---

### 16.7.5 状態のコピーを持つ

**落とし穴:** コンポーネントでStoreの状態をコピー

```csharp
// ❌ 間違い: 状態のコピーを持つ
private string _name = string.Empty;

protected override async Task OnInitializedAsync()
{
    Store.OnChangeAsync += HandleStateChanged;
    await Actions.LoadAsync(ProductId);
    _name = State.Product?.Name ?? "";  // ← コピー作成
}
```

**原因:**
- Single Source of Truth原則違反
- Storeの状態と同期が取れなくなる

**解決策:**
```csharp
// ✅ 正しい: Storeの状態を直接参照
<input @bind="State.Product.Name" />
```

**教訓:**
- コンポーネントは状態のコピーを持たない
- 常にStoreから直接取得

---

### 16.7.6 E2Eテストのタイムアウト

**よくある3つの原因:**

1. **Blazor Prerenderingエラー**
   - `OnInitializedAsync`でJS呼び出し
   - 解決: `OnAfterRenderAsync`に移動

2. **データが見つからない**
   - 異なるDbContextでデータ作成と読み取り
   - 解決: 同じDbContextを使用

3. **EF Core設定エラー**
   - Ignoreされたプロパティを`.Include()`
   - 解決: `OwnsMany`は自動ロード

**デバッグテクニック:**
- ブラウザコンソールログ収集
- 失敗時のスクリーンショット保存
- Store/Handler/Repositoryの詳細ログ
- デュアル待機戦略（ready信号 or DOMセレクタ）

---

### 16.7.7 MediatRハンドラーの未登録

**落とし穴:** Feature Assembliesの登録忘れ

```csharp
// ❌ 間違い: Assemblyが登録されていない
builder.Services.AddMediatR(cfg => 
{
    cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
    // GetProductByIdHandlerのアセンブリが含まれていない
});
```

**原因:**
- Vertical Slice Architectureでは各FeatureのHandlerが別アセンブリ
- 登録漏れでHandlerが見つからない

**解決策:**
```csharp
// ✅ 正しい: 全FeatureのAssemblyを登録
builder.Services.AddMediatR(cfg =>
{
    foreach (var assembly in Program.FeatureApplicationAssemblies)
    {
        cfg.RegisterServicesFromAssembly(assembly);
    }
});
```

**教訓:**
- VSAでは動的にFeatureアセンブリを収集
- 新機能追加時も自動的に登録される

---

### 16.7.8 まとめ

**よくある落とし穴TOP 5:**

1. **Blazor Prerendering時のJS呼び出し** → `OnAfterRenderAsync`を使う
2. **EF Core IncludeとIgnore/OwnsMany** → `OwnsMany`は自動ロード
3. **テストDBの不一致** → 同じDbContextを使う
4. **Store購読のメモリリーク** → `Dispose`で購読解除
5. **状態のコピー** → Storeから直接参照

**これらは技術固有の問題ではなく、Web開発の本質的な複雑さです。**
他のフレームワーク（React/Vue/Angular）でも同様のパターンが存在します。

---

