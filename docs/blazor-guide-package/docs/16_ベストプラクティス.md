# 16. ベストプラクティス

[← 目次に戻る](00_README.md)

---

## 16. ベストプラクティス

### 14.1 依存性注入のスコープ

```csharp
// ✅ 正しいスコープ設定

// Blazor Server Circuit単位
builder.Services.AddScoped<ProductsStore>();
builder.Services.AddScoped<ProductListActions>();

// 都度スコープで解決
builder.Services.AddScoped<AppDbContext>();
builder.Services.AddScoped<IMediator, Mediator>();

// Singleton(ステートレス)
builder.Services.AddSingleton<IIdGenerator, GuidGenerator>();

// Transient(軽量・ステートレス)
builder.Services.AddTransient<ICurrentUserService, CurrentUserService>();
```

### 14.2 エラーハンドリング

```csharp
// ✅ Result型による明示的なエラーハンドリング

public sealed record Result
{
    public bool IsSuccess { get; }
    public string? Error { get; }
    
    private Result(bool isSuccess, string? error)
    {
        IsSuccess = isSuccess;
        Error = error;
    }
    
    public static Result Success() => new(true, null);
    public static Result Fail(string error) => new(false, error);
}

public sealed record Result<T> : Result
{
    public T? Value { get; }
    
    private Result(bool isSuccess, T? value, string? error) : base(isSuccess, error)
    {
        Value = value;
    }
    
    public static Result<T> Success(T value) => new(true, value, null);
    public new static Result<T> Fail(string error) => new(false, default, error);
}
```

### 14.3 ロギング戦略

```csharp
// ✅ 構造化ロギング

_logger.LogInformation(
    "商品を削除しました: {ProductId}, ユーザー: {UserId}",
    productId,
    userId);

// ✅ ログレベルの適切な使い分け
// - Trace: 詳細なデバッグ情報
// - Debug: 開発時のデバッグ
// - Information: 正常な動作フロー
// - Warning: 予期しないが回復可能な状態
// - Error: エラー(例外)
// - Critical: 致命的なエラー
```

### 14.4 セキュリティ

```csharp
// ✅ 認可の一貫性

// 1. Command/Queryレベル
[Authorize(Roles = "Admin")]
public sealed record DeleteProductCommand(Guid ProductId) : ICommand<Result>;

// 2. UI レベル(ボタン非表示)
@if (CurrentUser.IsInRole("Admin"))
{
    <button @onclick="() => Actions.DeleteAsync(product.Id)">削除</button>
}

// 3. 多層防御
// - UI: ボタン非表示
// - PageActions: 追加チェック(オプション)
// - AuthorizationBehavior: 必須チェック
// - Handler: ビジネスルールチェック
```

### 14.5 設定管理

```json
// appsettings.json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=...;Database=...",
    "ReadOnlyConnection": "Server=replica...;ApplicationIntent=ReadOnly"
  },
  "Caching": {
    "ProductList": {
      "DurationMinutes": 5
    },
    "ProductDetail": {
      "DurationMinutes": 10
    }
  },
  "CircuitOptions": {
    "MaxRetainedDisconnectedCircuits": 100,
    "DisconnectedCircuitRetentionMinutes": 3
  }
}
```

### 14.6 Blazor Server運用ガイド(安全策集約) (v2.1改善)

**Blazor Server特有の注意点を一元化**

#### 14.6.1 再接続時の安全策

```csharp
// 1. Store再初期化の実装
public sealed class ProductsStore : IDisposable
{
    private bool _isInitialized;
    
    public async Task EnsureInitializedAsync(CancellationToken ct = default)
    {
        if (_isInitialized) return;
        
        await LoadAsync(ct);
        _isInitialized = true;
    }
}

// 2. Smart Componentでの利用
@code {
    protected override async Task OnInitializedAsync()
    {
        Store.OnChangeAsync += HandleStateChanged;
        
        // ✅ 再接続時にも初期化を保証
        await Store.EnsureInitializedAsync();
    }
    
    // ✅ 再接続検知とリロード
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // SignalR再接続イベントを購読
            await JSRuntime.InvokeVoidAsync("blazorReconnectHandler.register", 
                DotNetObjectReference.Create(this));
        }
    }
    
    [JSInvokable]
    public async Task OnReconnected()
    {
        _logger.LogInformation("SignalR再接続完了、データを再読込");
        await Store.LoadAsync();
    }
}

// JavaScript側(wwwroot/js/reconnect-handler.js)
window.blazorReconnectHandler = {
    register: function(dotNetHelper) {
        Blazor.defaultReconnectionHandler.onConnectionUp = async () => {
            await dotNetHelper.invokeMethodAsync('OnReconnected');
        };
    }
};
```

#### 14.6.2 回線断中の二重実行防止

```csharp
// Store側の防御
public sealed class ProductsStore
{
    private readonly SemaphoreSlim _gate = new(1, 1);
    private bool _isProcessing;
    
    public async Task<bool> DeleteAsync(Guid id, CancellationToken ct = default)
    {
        // ✅ 既に処理中なら拒否
        if (_isProcessing)
        {
            _logger.LogWarning("削除処理が既に実行中です");
            return false;
        }
        
        await _gate.WaitAsync(ct);
        try
        {
            _isProcessing = true;
            
            // ... 実際の削除処理
            
            return true;
        }
        finally
        {
            _isProcessing = false;
            _gate.Release();
        }
    }
}

// UI側の防御(ボタン無効化)
<button class="btn btn-danger" 
        @onclick="() => Actions.DeleteAsync(product.Id)"
        disabled="@_isDeleting">
    @if (_isDeleting)
    {
        <span class="spinner-border spinner-border-sm"></span>
    }
    削除
</button>

@code {
    private bool _isDeleting;
    
    private async Task HandleDelete(Guid id)
    {
        if (_isDeleting) return;  // ✅ 二重クリック防止
        
        _isDeleting = true;
        StateHasChanged();
        
        try
        {
            await Actions.DeleteAsync(id);
        }
        finally
        {
            _isDeleting = false;
            StateHasChanged();
        }
    }
}
```

#### 14.6.3 アンチフォージェリトークン

```csharp
// Program.cs
builder.Services.AddAntiforgery(options =>
{
    options.HeaderName = "X-CSRF-TOKEN";
    options.Cookie.Name = "__Host-X-CSRF-TOKEN";
    options.Cookie.SameSite = SameSiteMode.Strict;
    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
});

// _Host.cshtml または App.razor
<component type="typeof(App)" render-mode="ServerPrerendered" />
<script src="_framework/blazor.server.js" 
        asp-append-version="true"
        data-antiforgery-token="@Html.GetAntiforgeryToken()"></script>

// Blazor Component での利用
@inject IAntiforgery Antiforgery

@code {
    [CascadingParameter]
    private HttpContext? HttpContext { get; set; }
    
    private async Task SubmitFormAsync()
    {
        // ✅ トークン検証
        await Antiforgery.ValidateRequestAsync(HttpContext!);
        
        // ... フォーム送信処理
    }
}
```

#### 14.6.4 サーキットごとのIServiceScope作法

```csharp
// ❌ BAD: Storeに直接DbContextをDI
public class ProductsStore
{
    private readonly AppDbContext _context;  // ❌ Circuit寿命と同じになる
    
    public ProductsStore(AppDbContext context)
    {
        _context = context;  // メモリリークの原因
    }
}

// ✅ GOOD: IServiceScopeFactoryで都度スコープ作成
public class ProductsStore
{
    private readonly IServiceScopeFactory _scopeFactory;  // ✅ 推奨
    
    public async Task LoadAsync(CancellationToken ct)
    {
        // ✅ 新しいスコープを作成
        using var scope = _scopeFactory.CreateScope();
        var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
        
        // MediatorのPipeline内でDbContextが解決される
        var result = await mediator.Send(new GetProductsQuery(), ct);
        
        // スコープ終了時にDbContextが自動Dispose
    }
}

// ✅ GOOD: Handlerでの利用(スコープは自動管理)
public class GetProductsQueryHandler : IRequestHandler<GetProductsQuery, Result<...>>
{
    private readonly AppDbContext _context;  // ✅ OK: Handler寿命はリクエストスコープ
    
    public GetProductsQueryHandler(AppDbContext context)
    {
        _context = context;  // リクエストごとに新しいインスタンス
    }
    
    public async Task<Result<...>> Handle(GetProductsQuery query, CancellationToken ct)
    {
        // ... クエリ実行
    }
}
```

#### 14.6.5 Circuit健全性チェックリスト

**運用前に以下を確認**:

| 項目 | チェック内容 | 対策 |
|------|------------|------|
| **1. メモリリーク** | Storeに長寿命依存がないか | IServiceScopeFactory使用 |
| **2. イベント購読解除** | Dispose時に購読解除しているか | IDisposable実装 |
| **3. 再接続処理** | 再接続時の初期化ロジックがあるか | EnsureInitializedAsync実装 |
| **4. 二重実行防止** | 処理中フラグとセマフォがあるか | SemaphoreSlim + _isProcessing |
| **5. CSRF対策** | アンチフォージェリトークン使用 | IAntiforgery設定 |
| **6. Circuit制限** | 切断Circuit保持数を設定 | appsettings.json設定 |
| **7. タイムアウト設定** | JSInterop/SignalRタイムアウト | CircuitOptions設定 |
| **8. エラーログ** | Circuit切断/再接続をログ | ILogger使用 |

#### 14.6.6 運用設定の推奨値

```csharp
// Program.cs
builder.Services.AddServerSideBlazor(options =>
{
    // ✅ 本番環境推奨設定
    options.DetailedErrors = false;  // 本番はfalse
    options.DisconnectedCircuitMaxRetained = 100;  // 最大保持Circuit数
    options.DisconnectedCircuitRetentionPeriod = TimeSpan.FromMinutes(3);  // 保持時間
    options.JSInteropDefaultCallTimeout = TimeSpan.FromMinutes(1);  // JSタイムアウト
    options.MaxBufferedUnacknowledgedRenderBatches = 10;  // レンダリングバッファ
});

// appsettings.Production.json
{
  "CircuitOptions": {
    "MaxRetainedDisconnectedCircuits": 100,
    "DisconnectedCircuitRetentionMinutes": 3,
    "JSInteropTimeoutMinutes": 1
  },
  "Logging": {
    "LogLevel": {
      "Microsoft.AspNetCore.SignalR": "Warning",  // SignalRログを抑制
      "Microsoft.AspNetCore.Http.Connections": "Warning"
    }
  }
}
```

#### 14.6.7 トラブルシューティングガイド

**よくある問題と解決策**:

```csharp
// 問題1: "Circuit not found" エラー
// 原因: Circuit保持時間を超えた、またはサーバー再起動
// 解決策: 
// - DisconnectedCircuitRetentionPeriodを延長
// - 再接続時のEnsureInitializedAsync実装
// - ユーザーに再読込を促すUI表示

// 問題2: メモリ使用量の増加
// 原因: DbContextがCircuit寿命で保持されている
// 解決策:
// - StoreでIServiceScopeFactoryを使用
// - 不要なInclude/Trackingを削除
// - Circuit数を監視(メトリクス)

// 問題3: SignalR接続エラーの多発
// 原因: WebSocketsが無効、またはプロキシ問題
// 解決策:
// - WebSocketsを有効化
// - Long Pollingフォールバック設定
// - nginxなどのプロキシ設定確認

// 問題4: 再接続後にデータが古い
// 原因: 再接続時の再初期化が未実装
// 解決策:
// - OnReconnectedイベントで再読込
// - SignalRでのキャッシュ無効化通知
```

**監視すべきメトリクス**:

```csharp
// Application Insights / Prometheus メトリクス
// - active_circuits: アクティブなCircuit数
// - disconnected_circuits: 切断されたCircuit数
// - reconnection_count: 再接続回数
// - circuit_lifetime_seconds: Circuit寿命の分布
// - memory_per_circuit_mb: Circuit当たりのメモリ使用量
```

---

