# 2. アーキテクチャ概要

[← 目次に戻る](00_README.md)

---

## 2. アーキテクチャ概要

### 2.1 設計原則

#### **1. 関心事の分離 (Separation of Concerns)**

```
UI層       → 表示と手順のオーケストレーション
Application層 → ユースケースの実行
Domain層    → ビジネスルール
Infrastructure層 → 技術的詳細(DB、外部API等)
```

#### **2. 依存性逆転の原則 (DIP)**

```
┌─────────────────────────────────────────────┐
│  UI Layer (Blazor Components)               │
│    ↓ 依存                                   │
│  Application Layer (UseCases/Handlers)      │
│    ↓ 依存                                   │
│  Domain Layer (Business Rules) ←────────┐   │
│    ↑ 実装                               │   │
│  Infrastructure Layer (Repositories) ───┘   │
└─────────────────────────────────────────────┘

依存の方向:UI → Application → Domain ← Infrastructure
```

#### **3. 不変性 (Immutability)**

```csharp
// ✅ 不変State(recordで定義)
public record ProductsState
{
    public ImmutableList<ProductDto> Products { get; init; } = ImmutableList<ProductDto>.Empty;
    public bool IsLoading { get; init; }
    public string? ErrorMessage { get; init; }
}

// ✅ 状態更新は常に新しいインスタンス
SetState(_state with { IsLoading = true });
```

#### **4. 明示的な副作用 (Explicit Side Effects)**

```csharp
// ✅ 副作用の場所が明確
PageActions → Store → Mediator → Handler → Repository

// ❌ 副作用が散在
Component内でDB直接アクセス、API呼び出し、ファイル操作等が混在
```

### 2.2 アーキテクチャスタイル

このアーキテクチャは以下のスタイルを組み合わせています:

#### **パターンカタログ型Clean Architecture**

**🎯 このプロジェクトの特徴:**

このプロジェクトは、**AI駆動開発のための実装パターンカタログ**として設計されています。
従来の「層分離」と「機能凝集」のバランスを取り、AIが参照しやすいフォルダ構成を採用しています。

**フォルダ構成:**

```
src/
├── ProductCatalog.Web/                    # UI層
│   └── Features/
│       └── Products/                      # 機能別に整理
│           ├── Pages/
│           ├── Actions/
│           ├── Store/
│           └── Components/
│
├── ProductCatalog.Application/            # Application層
│   └── Features/
│       └── Products/                      # 機能別に整理
│           ├── CreateProduct/             # ← パターン単位で凝集
│           │   ├── CreateProductCommand.cs
│           │   ├── CreateProductHandler.cs
│           │   └── CreateProductValidator.cs
│           ├── UpdateProduct/             # ← パターン単位で凝集
│           │   ├── UpdateProductCommand.cs
│           │   ├── UpdateProductHandler.cs
│           │   └── UpdateProductValidator.cs
│           ├── DeleteProduct/
│           ├── GetProducts/
│           ├── GetProductById/
│           ├── SearchProducts/
│           └── BulkDeleteProducts/
│
├── ProductCatalog.Domain/                 # Domain層
│   ├── Common/
│   │   ├── AggregateRoot.cs              # 集約ルート基底クラス
│   │   ├── Entity.cs
│   │   └── ValueObject.cs
│   └── Products/
│       ├── Product.cs                     # 集約ルート
│       ├── ProductImage.cs                # 子エンティティ
│       ├── ProductId.cs
│       ├── Money.cs
│       └── ProductStatus.cs
│
└── ProductCatalog.Infrastructure/         # Infrastructure層
    ├── Persistence/
    │   ├── Repositories/
    │   └── Configurations/
    ├── Behaviors/                         # 横断的関心事
    └── Outbox/
```

**なぜこの構成なのか？（AI視点）**

✅ **パターン単位で完結**
- 「更新機能を実装したい」→ `UpdateProduct/` フォルダを見るだけ
- Command/Handler/Validatorが1箇所に集約
- 機能の追加・削除が容易

✅ **層分離は維持**
- Clean Architectureの依存方向は厳守
- DIP（依存性逆転の原則）を適用
- テスタビリティを確保

✅ **AIが参照しやすい**
- 同種のパターン（全てのCommand、全てのQuery）を比較しやすい
- CQRSの区別が明確
- 実装パターンの発見性が高い

**従来のVSA（全層を1フォルダに集約）との違い:**

| 観点 | 従来のVSA | このプロジェクト |
|-----|----------|----------------|
| 層分離 | 機能ごとに全層を含む | 層は分離、層内で機能別整理 |
| 依存方向 | 機能内で完結 | Clean Architectureの依存方向 |
| AI参照 | 機能全体を見る | パターン単位で見る |
| 適用場面 | 機能間の結合が弱い場合 | パターン学習・再利用 |

**メリット:**
- 📚 **パターンカタログとして最適** - AIが同種のパターンを比較学習しやすい
- 🔍 **高い発見性** - 「検索機能を実装したい」→ `SearchProducts/` を参照
- 🏗️ **拡張性** - 新しいパターンをフォルダ単位で追加
- 🧪 **テスタビリティ** - 層分離により単体テストが容易
- 📖 **明確な責務** - CQRS により読み取り/書き込みが明確

#### **CQRS (Command Query Responsibility Segregation)**

```csharp
// Query: 読み取り専用、最適化された取得
public record GetProductsQuery : IQuery<Result<IEnumerable<ProductDto>>>;

// Command: 書き込み、ビジネスルール適用
public record DeleteProductCommand(Guid Id) : ICommand<Result>;
```

**メリット:**
- 読み取りと書き込みを独立して最適化
- 複雑なクエリをシンプルに
- キャッシュ戦略の適用が容易

#### **Event-Driven Architecture (EDA)**

```csharp
// ドメインイベント
public record ProductDeletedEvent(Guid ProductId, DateTime DeletedAt);

// 統合イベント(Outbox経由で配信)
public record ProductDeletedIntegrationEvent(
    string EventId,
    Guid ProductId,
    DateTime DeletedAt
);

// SignalRでリアルタイム通知
await _hubContext.Clients.All.SendAsync("ProductDeleted", productId);
```

**メリット:**
- 疎結合な機能間連携
- リアルタイムUI更新
- 外部システムとの統合が容易

---
