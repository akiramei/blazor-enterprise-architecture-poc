# 2. アーキテクチャ概要

[← 目次に戻る](00_README.md)

---

## 2. アーキテクチャ概要

### 2.1 設計原則

#### **1. 関心事の分離 (Separation of Concerns)**

```
UI層       → 表示と手順のオーケストレーション
Application層 → ユースケースの実行
Domain層    → ビジネスルール
Infrastructure層 → 技術的詳細(DB、外部API等)
```

#### **2. 依存性逆転の原則 (DIP)**

```
┌─────────────────────────────────────────────┐
│  UI Layer (Blazor Components)               │
│    ↓ 依存                                   │
│  Application Layer (UseCases/Handlers)      │
│    ↓ 依存                                   │
│  Domain Layer (Business Rules) ←────────┐   │
│    ↑ 実装                               │   │
│  Infrastructure Layer (Repositories) ───┘   │
└─────────────────────────────────────────────┘

依存の方向:UI → Application → Domain ← Infrastructure
```

#### **3. 不変性 (Immutability)**

```csharp
// ✅ 不変State(recordで定義)
public record ProductsState
{
    public ImmutableList<ProductDto> Products { get; init; } = ImmutableList<ProductDto>.Empty;
    public bool IsLoading { get; init; }
    public string? ErrorMessage { get; init; }
}

// ✅ 状態更新は常に新しいインスタンス
SetState(_state with { IsLoading = true });
```

#### **4. 明示的な副作用 (Explicit Side Effects)**

```csharp
// ✅ 副作用の場所が明確
PageActions → Store → Mediator → Handler → Repository

// ❌ 副作用が散在
Component内でDB直接アクセス、API呼び出し、ファイル操作等が混在
```

### 2.2 アーキテクチャスタイル

このアーキテクチャは以下のスタイルを組み合わせています:

#### **パターンカタログ型Clean Architecture**

**🎯 このプロジェクトの特徴:**

このプロジェクトは、**AI駆動開発のための実装パターンカタログ**として設計されています。
従来の「層分離」と「機能凝集」のバランスを取り、AIが参照しやすいフォルダ構成を採用しています。

**フォルダ構成:**

```
src/
├── ProductCatalog.Web/                    # UI層
│   └── Features/
│       └── Products/                      # 機能別に整理
│           ├── Pages/
│           ├── Actions/
│           ├── Store/
│           └── Components/
│
├── ProductCatalog.Application/            # Application層
│   └── Features/
│       └── Products/                      # 機能別に整理
│           ├── CreateProduct/             # ← パターン単位で凝集
│           │   ├── CreateProductCommand.cs
│           │   ├── CreateProductHandler.cs
│           │   └── CreateProductValidator.cs
│           ├── UpdateProduct/             # ← パターン単位で凝集
│           │   ├── UpdateProductCommand.cs
│           │   ├── UpdateProductHandler.cs
│           │   └── UpdateProductValidator.cs
│           ├── DeleteProduct/
│           ├── GetProducts/
│           ├── GetProductById/
│           ├── SearchProducts/
│           └── BulkDeleteProducts/
│
├── ProductCatalog.Domain/                 # Domain層
│   ├── Common/
│   │   ├── AggregateRoot.cs              # 集約ルート基底クラス
│   │   ├── Entity.cs
│   │   └── ValueObject.cs
│   └── Products/
│       ├── Product.cs                     # 集約ルート
│       ├── ProductImage.cs                # 子エンティティ
│       ├── ProductId.cs
│       ├── Money.cs
│       └── ProductStatus.cs
│
└── ProductCatalog.Infrastructure/         # Infrastructure層
    ├── Persistence/
    │   ├── Repositories/
    │   └── Configurations/
    ├── Behaviors/                         # 横断的関心事
    └── Outbox/
```

**なぜこの構成なのか？（AI視点）**

✅ **パターン単位で完結**
- 「更新機能を実装したい」→ `UpdateProduct/` フォルダを見るだけ
- Command/Handler/Validatorが1箇所に集約
- 機能の追加・削除が容易

✅ **層分離は維持**
- Clean Architectureの依存方向は厳守
- DIP（依存性逆転の原則）を適用
- テスタビリティを確保

✅ **AIが参照しやすい**
- 同種のパターン（全てのCommand、全てのQuery）を比較しやすい
- CQRSの区別が明確
- 実装パターンの発見性が高い

**従来のVSA（全層を1フォルダに集約）との違い:**

| 観点 | 従来のVSA | このプロジェクト |
|-----|----------|----------------|
| 層分離 | 機能ごとに全層を含む | 層は分離、層内で機能別整理 |
| 依存方向 | 機能内で完結 | Clean Architectureの依存方向 |
| AI参照 | 機能全体を見る | パターン単位で見る |
| 適用場面 | 機能間の結合が弱い場合 | パターン学習・再利用 |

**メリット:**
- 📚 **パターンカタログとして最適** - AIが同種のパターンを比較学習しやすい
- 🔍 **高い発見性** - 「検索機能を実装したい」→ `SearchProducts/` を参照
- 🏗️ **拡張性** - 新しいパターンをフォルダ単位で追加
- 🧪 **テスタビリティ** - 層分離により単体テストが容易
- 📖 **明確な責務** - CQRS により読み取り/書き込みが明確

#### **CQRS (Command Query Responsibility Segregation)**

```csharp
// Query: 読み取り専用、最適化された取得
public record GetProductsQuery : IQuery<Result<IEnumerable<ProductDto>>>;

// Command: 書き込み、ビジネスルール適用
public record DeleteProductCommand(Guid Id) : ICommand<Result>;
```

**メリット:**
- 読み取りと書き込みを独立して最適化
- 複雑なクエリをシンプルに
- キャッシュ戦略の適用が容易

#### **Event-Driven Architecture (EDA)**

```csharp
// ドメインイベント
public record ProductDeletedEvent(Guid ProductId, DateTime DeletedAt);

// 統合イベント(Outbox経由で配信)
public record ProductDeletedIntegrationEvent(
    string EventId,
    Guid ProductId,
    DateTime DeletedAt
);

// SignalRでリアルタイム通知
await _hubContext.Clients.All.SendAsync("ProductDeleted", productId);
```

**メリット:**
- 疎結合な機能間連携
- リアルタイムUI更新
- 外部システムとの統合が容易

---

### 2.3 3層アーキテクチャとの対応表

**WPF/WinForms + RESTful Web API 経験者向けのマッピング**

このアーキテクチャは、古典的な3層アーキテクチャの概念を踏襲しつつ、現代的なパターンで再構築しています。

#### **全体対応表**

| 3層アーキテクチャ | このアーキテクチャ | 主な変更点 |
|----------------|-----------------|----------|
| **Presentation Layer** | **UI Layer (Blazor)** | WPF/WinForms → Blazor Component |
| ViewModel | **Store + PageActions** | 責務を分離（状態管理 + 手順） |
| View | Smart/Dumb Component | Container/Presentational分離 |
| **Business Logic Layer** | **Application Layer** | Service → MediatR Handler |
| ServiceクラスのDI | MediatR + Pipeline Behaviors | 横断的関心事の統一 |
| DTOマッピング | Command/Query | CQRS適用 |
| **Data Access Layer** | **Infrastructure Layer** | ほぼ同じ概念 |
| Repository | Repository | インターフェイスはDomain層に配置 |
| DbContext | DbContext | 寿命管理が厳密化 |

#### **詳細な対応: ビジネスロジック層**

**3層アーキテクチャ（従来）:**
```csharp
// Serviceクラスに全てを実装
public class ProductService : IProductService
{
    private readonly IProductRepository _repository;
    private readonly ILogger _logger;
    private readonly IAuthorizationService _authz;

    public async Task<Result> DeleteProductAsync(Guid id)
    {
        // 1. ログ出力
        _logger.LogInformation("商品削除開始: {Id}", id);

        // 2. 認可チェック
        if (!await _authz.AuthorizeAsync("Product.Delete"))
            return Result.Fail("権限がありません");

        // 3. トランザクション
        using var transaction = await _dbContext.Database.BeginTransactionAsync();
        try {
            // 4. ビジネスロジック
            var product = await _repository.GetAsync(id);
            await _repository.DeleteAsync(product);
            await _dbContext.SaveChangesAsync();
            await transaction.CommitAsync();
        }
        catch { await transaction.RollbackAsync(); throw; }

        // 5. 監査ログ
        await _auditLog.SaveAsync(new AuditEntry(...));

        return Result.Success();
    }
}
```

**このアーキテクチャ:**
```csharp
// Handlerはビジネスロジックのみ
public class DeleteProductHandler : IRequestHandler<DeleteProductCommand, Result>
{
    private readonly IProductRepository _repository;

    public async Task<Result> Handle(DeleteProductCommand cmd, CancellationToken ct)
    {
        // ビジネスロジックのみ！
        // ログ、認可、トランザクション、監査ログは自動適用
        var product = await _repository.GetAsync(new ProductId(cmd.ProductId), ct);
        if (product is null) return Result.Fail("商品が見つかりません");

        product.Delete();  // ドメインルール
        await _repository.SaveAsync(product, ct);
        return Result.Success();
    }
}

// Pipeline Behaviors（DI登録で自動適用）
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(AuthorizationBehavior<,>));
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(TransactionBehavior<,>));
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(AuditLogBehavior<,>));
```

**違い:**
- **3層**: 横断的関心事が各Serviceクラスに散在
- **このアーキテクチャ**: Pipeline Behaviorsで一箇所に集約、自動適用

詳細は [08_Application層の詳細設計 - 8.0 なぜMediatRが必要か？](08_Application層の詳細設計.md#80-なぜmediatrが必要か-serviceクラス直接diとの比較) を参照してください。

#### **詳細な対応: UI層**

**3層アーキテクチャ（WPF/WinForms）:**
```csharp
// ViewModelに全てを実装
public class ProductListViewModel : INotifyPropertyChanged
{
    private ObservableCollection<Product> _products = new();
    public ObservableCollection<Product> Products
    {
        get => _products;
        set { _products = value; OnPropertyChanged(); }
    }

    public ICommand DeleteCommand { get; }

    private async Task DeleteProductAsync(Guid id)
    {
        var result = MessageBox.Show("削除しますか?", "確認", MessageBoxButton.YesNo);
        if (result == MessageBoxResult.No) return;

        await _productService.DeleteAsync(id);
        Products.Remove(Products.First(p => p.Id == id));
    }
}
```

**このアーキテクチャ:**
```csharp
// Store: 状態管理のみ
public class ProductsStore
{
    private ProductsState _state = new();  // 不変状態
    public event Func<Task>? OnChangeAsync;

    public async Task<bool> DeleteAsync(Guid id, CancellationToken ct = default)
    {
        // I/O実行と状態更新
        using var scope = _scopeFactory.CreateScope();
        var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
        var result = await mediator.Send(new DeleteProductCommand(id), ct);

        if (result.IsSuccess)
            await LoadAsync(ct);  // 状態再取得

        return result.IsSuccess;
    }
}

// PageActions: UI手順のオーケストレーション
public class ProductListActions
{
    public async Task DeleteAsync(Guid id, CancellationToken ct = default)
    {
        // UI手順の制御のみ
        if (!await _confirm.ShowAsync("削除しますか?")) return;

        var result = await _store.DeleteAsync(id, ct);

        if (result) _toast.Success("削除しました");
        else _toast.Error("削除に失敗しました");
    }
}
```

**違い:**
- **3層**: ViewModel に状態管理とUI手順が混在
- **このアーキテクチャ**: Store（状態） + PageActions（手順）に分離

詳細は [07_UI層の詳細設計 - 7.0 WPF/WinFormsとの比較](07_UI層の詳細設計.md#70-wpfwinformsとの比較) を参照してください。

---

### 2.4 フロントエンド状態管理との概念比較

**React/Vue界隈の状態管理ライブラリとの関係**

このアーキテクチャの**Storeパターン**は、React/Vue界隈でよく使われる以下の状態管理ライブラリと**似た概念**を採用しています。

#### **参考にした概念**

| ライブラリ | 概要 | このアーキテクチャでの対応 |
|----------|------|------------------------|
| **Jotai** | Reactのアトミック状態管理 | Store の不変状態管理 |
| **Redux** | 単方向データフローの状態管理 | Store の単方向データフロー |
| **Zustand** | シンプルなReact状態管理 | Store の軽量実装 |
| **Recoil** | Facebookの状態管理 | Store のイベント駆動 |

**注意:** これらのライブラリを**直接使用するわけではありません**。Blazorに最適化した独自実装を行っています。

#### **共通する設計概念**

##### **1. 不変（Immutable）な状態管理**

```csharp
// ✅ このアーキテクチャ（Storeパターン）
public record ProductsState
{
    public ImmutableList<ProductDto> Products { get; init; } = ImmutableList<ProductDto>.Empty;
    public bool IsLoading { get; init; }
}

// 状態更新は新しいインスタンス生成
SetState(_state with { IsLoading = true });
```

```javascript
// 参考: Jotai (React)
const productsAtom = atom([]);
const isLoadingAtom = atom(false);

// 状態更新は新しい値をセット
setProducts([...products, newProduct]);
```

**共通点:**
- 状態オブジェクトを直接変更しない（Immutable）
- 常に新しいインスタンスを生成して差し替える
- 予測可能な状態遷移

##### **2. 単方向データフロー**

```
[このアーキテクチャ]          [Redux/Jotai]
Action/Event                  Action
  ↓                            ↓
Store.UpdateState()          Reducer/Setter
  ↓                            ↓
Store.OnChangeAsync          Subscriber
  ↓                            ↓
Component.StateHasChanged()  Component Re-render
```

**共通点:**
- データは一方向にのみ流れる
- 状態更新がトリガーとなって再描画
- デバッグがしやすい

##### **3. イベント駆動の再描画**

```csharp
// ✅ このアーキテクチャ
public class ProductsStore
{
    public event Func<Task>? OnChangeAsync;  // イベント

    private void SetState(ProductsState newState)
    {
        _state = newState;
        OnChangeAsync?.Invoke();  // 購読者に通知
    }
}

// Component での購読
protected override void OnInitialized()
{
    Store.OnChangeAsync += () => InvokeAsync(StateHasChanged);
}
```

```javascript
// 参考: Zustand (React)
const useProductsStore = create((set) => ({
  products: [],
  setProducts: (products) => set({ products }),  // 自動で購読者に通知
}));

// Component での使用
const products = useProductsStore((state) => state.products);  // 自動購読
```

**共通点:**
- 状態変更を購読（Subscribe）する仕組み
- 状態が変わると自動で通知される
- 手動でのポーリングは不要

#### **WPF/WinFormsのMVVMとの違い**

| 観点 | MVVM (WPF/WinForms) | Store Pattern (このアーキテクチャ) | Jotai/Redux (React) |
|------|-------------------|-------------------------------|-------------------|
| **状態の可変性** | 可変（Mutable） | 不変（Immutable） | 不変（Immutable） |
| **変更通知** | INotifyPropertyChanged | OnChangeAsync イベント | Subscriber通知 |
| **データバインディング** | 双方向バインディング | 単方向データフロー | 単方向データフロー |
| **状態更新** | プロパティ直接変更 | 新しいインスタンス生成 | 新しいインスタンス生成 |

**例: 商品リスト更新**

```csharp
// ❌ MVVM (WPF) - 可変状態
Products.Add(newProduct);  // ObservableCollectionを直接変更

// ✅ Store Pattern - 不変状態
SetState(_state with {
    Products = _state.Products.Add(newProduct)  // 新しいリスト生成
});
```

**メリット:**
- **デバッグが容易**: 状態履歴をトレースしやすい
- **並行制御**: 不変なので競合が起きにくい
- **時間旅行デバッグ**: 状態のスナップショットを保存可能

詳細は [07_UI層の詳細設計 - 7.2 Storeパターン](07_UI層の詳細設計.md#72-storeパターン) を参照してください。

---
