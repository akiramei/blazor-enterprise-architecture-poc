# 2. アーキテクチャ概要

[← 目次に戻る](00_README.md)

---

## 2. アーキテクチャ概要

### 2.1 設計原則

#### **1. 関心事の分離 (Separation of Concerns)**

```
UI層       → 表示と手順のオーケストレーション
Application層 → ユースケースの実行
Domain層    → ビジネスルール
Infrastructure層 → 技術的詳細(DB、外部API等)
```

#### **2. 依存性逆転の原則 (DIP)**

```
┌─────────────────────────────────────────────┐
│  UI Layer (Blazor Components)               │
│    ↓ 依存                                   │
│  Application Layer (UseCases/Handlers)      │
│    ↓ 依存                                   │
│  Domain Layer (Business Rules) ←────────┐   │
│    ↑ 実装                               │   │
│  Infrastructure Layer (Repositories) ───┘   │
└─────────────────────────────────────────────┘

依存の方向:UI → Application → Domain ← Infrastructure
```

#### **3. 不変性 (Immutability)**

```csharp
// ✅ 不変State(recordで定義)
public record ProductsState
{
    public ImmutableList<ProductDto> Products { get; init; } = ImmutableList<ProductDto>.Empty;
    public bool IsLoading { get; init; }
    public string? ErrorMessage { get; init; }
}

// ✅ 状態更新は常に新しいインスタンス
SetState(_state with { IsLoading = true });
```

#### **4. 明示的な副作用 (Explicit Side Effects)**

```csharp
// ✅ 副作用の場所が明確
PageActions → Store → Mediator → Handler → Repository

// ❌ 副作用が散在
Component内でDB直接アクセス、API呼び出し、ファイル操作等が混在
```

### 2.2 アーキテクチャスタイル

このアーキテクチャは以下のスタイルを組み合わせています:

#### **Vertical Slice Architecture (VSA)**

```
/Features/
  /Products/          ← 商品機能のすべてがここに凝集
    /UI/
      ProductList.razor
      ProductList.Actions.cs
      ProductsStore.cs
      ProductsState.cs
    /UseCases/
      DeleteProduct/
        DeleteProductCommand.cs
        DeleteProductHandler.cs
    /Domain/
      Product.cs
    /Infrastructure/
      EfProductRepository.cs
```

**メリット:**
- 機能追加時の影響範囲が限定的
- チームメンバーが並行作業しやすい
- 不要な機能の削除が容易

#### **CQRS (Command Query Responsibility Segregation)**

```csharp
// Query: 読み取り専用、最適化された取得
public record GetProductsQuery : IQuery<Result<IEnumerable<ProductDto>>>;

// Command: 書き込み、ビジネスルール適用
public record DeleteProductCommand(Guid Id) : ICommand<Result>;
```

**メリット:**
- 読み取りと書き込みを独立して最適化
- 複雑なクエリをシンプルに
- キャッシュ戦略の適用が容易

#### **Event-Driven Architecture (EDA)**

```csharp
// ドメインイベント
public record ProductDeletedEvent(Guid ProductId, DateTime DeletedAt);

// 統合イベント(Outbox経由で配信)
public record ProductDeletedIntegrationEvent(
    string EventId,
    Guid ProductId,
    DateTime DeletedAt
);

// SignalRでリアルタイム通知
await _hubContext.Clients.All.SendAsync("ProductDeleted", productId);
```

**メリット:**
- 疎結合な機能間連携
- リアルタイムUI更新
- 外部システムとの統合が容易

---
